<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Acoustic Sum Rule · AtomicSymmetries.jl Documentation</title><meta name="title" content="Acoustic Sum Rule · AtomicSymmetries.jl Documentation"/><meta property="og:title" content="Acoustic Sum Rule · AtomicSymmetries.jl Documentation"/><meta property="twitter:title" content="Acoustic Sum Rule · AtomicSymmetries.jl Documentation"/><meta name="description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="og:description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="twitter:description" content="Documentation for AtomicSymmetries.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AtomicSymmetries.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Acoustic Sum Rule</a></li><li><a class="tocitem" href="../fourier_symmetries/">Symmetries in Q space</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Acoustic Sum Rule</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Acoustic Sum Rule</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/main/docs/src/acoustic_sum_rule.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Acoustic-sum-rule"><a class="docs-heading-anchor" href="#Acoustic-sum-rule">Acoustic sum rule</a><a id="Acoustic-sum-rule-1"></a><a class="docs-heading-anchor-permalink" href="#Acoustic-sum-rule" title="Permalink"></a></h1><p>One fundamental aspect of symmetries of phonons is the so called acoustic sum rule. This properties stems from the invariance of physical properties to global translations, and it is reflected to the fact that acoustic phonons, at the center of the Brilluin zone, have a vaninshing energy.</p><p>Therefore, the force constant matrix in real space, has always a kernel of dimension equal to the number of acoustic phonons: i.e. the number of operations under which the system is completely invariant.</p><p>The application of the acoustic sum rule depends on the dimensionality of the system, as well as the number of dimension. <code>AtomicSymmetries.jl</code> implements acoustic sum rules via defining a set of rules to compute it.</p><p>The standard acoustic sum rule is imposed by defining a structure <code>ASRConstraint!</code> which contains the dimension of the system. Then, the structure can act as a method to vectors and force constant matrices imposing the ASR condition on them.</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.ASRConstraint!"><a class="docstring-binding" href="#AtomicSymmetries.ASRConstraint!"><code>AtomicSymmetries.ASRConstraint!</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>ASRConstraint!</p><p>Apply the ASR constraint to a rank-<code>rank</code> tensor of dimension <code>dimension</code>. The application works as </p><pre><code class="language-julia hljs">my_asr! = ASRconstraint!(dimension, 2)
my_tensor = rand(nat * dimension, nat * dimension)
my_asr!(my_tensor)</code></pre><p>This will apply the ASR constraint to the tensor <code>my_tensor</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/4b1e8d3ccdd5b6405fad69eb824496f3deaf8085/src/asr.jl#L1-L14">source</a></section></details></article><p>It is possible to automatically identify translational modes with <code>translation_mask!</code> subroutine, which returns false to modes that are purely translational. This is very important to selectively optimize only a subset of modes.</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.translation_mask!"><a class="docstring-binding" href="#AtomicSymmetries.translation_mask!"><code>AtomicSymmetries.translation_mask!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">translation_mask!(mask::Vector{Bool}, pols::Matrix{T}, masses::Vector{T}; buffer=default_buffer()) where T</code></pre><p>Identifies non-translational modes (e.g., optical modes) by checking if the crystal&#39;s center of mass moves.</p><p>The function updates the <code>mask</code> in-place, setting <code>mask[i] = true</code> for any mode <code>i</code> that does <strong>not</strong> move the center of mass.</p><p><strong>Mathematical and Physical Interpretation</strong></p><p>This function correctly computes the (unnormalized) displacement of the center of mass for each mode <code>i</code>.</p><ol><li><p><strong>Assumption:</strong> The <code>pols</code> matrix contains the standard  <strong>mass-weighted</strong> polarization eigenvectors, <span>$e_{j,\alpha}$</span>.  These relate to the real-space displacement vectors <span>$u_{j,\alpha}$</span>  by the formula:  <span>$e_{j,\alpha} = \sqrt{m_j} \cdot u_{j,\alpha}$</span></p></li><li><p><strong>Calculation:</strong> The function computes a <code>ndims</code>-sized vector <code>dispv</code>  for each mode. The calculation is:  <span>$\texttt{dispv}_\alpha = \sum_j \left( \texttt{pols}_{j,\alpha}^{(i)} \cdot \sqrt{\texttt{masses}_j} \right)$</span></p></li><li><p><strong>Substitution:</strong> By substituting the definition from (1), we see  what <code>dispv</code> physically represents:  <span>$\texttt{dispv}_\alpha = \sum_j \left( (\sqrt{m_j} \cdot u_{j,\alpha}^{(i)}) \cdot \sqrt{m_j} \right)                       = \sum_j \left( m_j \cdot u_{j,\alpha}^{(i)} \right)$</span>  This vector <code>dispv</code> is the component-wise sum of mass-weighted  real-space displacements. This is equal to the total mass of the  system times the displacement of its center of mass  (<span>$M_{\text{tot}} \cdot U_{\text{cm}}$</span>).</p></li><li><p><strong>Condition:</strong> The check <code>max(abs.(dispv)...) &lt;= 1e-6</code> is <code>true</code>  if and only if <code>dispv</code> is the zero vector.</p><ul><li><strong>Non-translational modes</strong> (like optical modes, or acoustic   modes at <span>$\mathbf{q} \neq 0$</span>) are <em>defined</em> by the   property that they do not move the center of mass (<span>$U_{\text{cm}} = 0$</span>).   For these modes, <code>dispv</code> is zero, the check passes,   and <code>mask[i]</code> is set to <code>true</code>.</li><li><strong>Translational modes</strong> (the 3 acoustic modes at <span>$\mathbf{q} = 0$</span>)   <em>do</em> move the center of mass (<span>$U_{\text{cm}} \neq 0$</span>).   For these modes, <code>dispv</code> is non-zero, the check fails,   and <code>mask[i]</code> remains <code>false</code>.</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>mask::Vector{Bool}</code>: The boolean mask to be updated in-place. <code>mask[i]</code> will be set to <code>true</code> for non-translational modes.</li><li><code>pols::Matrix{T}</code>: The matrix of <strong>mass-weighted</strong> polarization eigenvectors, with modes as columns. Must have size <code>(Ndims * Natoms, Nmodes)</code>.</li><li><code>masses::Vector{T}</code>: A vector of the <strong>atomic masses</strong> for each atom, with size <code>(Natoms)</code>.</li><li><code>buffer</code>: (Optional) A <code>Bumper.jl</code> buffer for allocating the temporary <code>dispv</code> vector to avoid allocations.</li></ul><div class="admonition is-info" id="Finding-Translational-Modes-df4d8ac5932d36a2"><header class="admonition-header">Finding Translational Modes<a class="admonition-anchor" href="#Finding-Translational-Modes-df4d8ac5932d36a2" title="Permalink"></a></header><div class="admonition-body"><p>This function finds modes where <code>mask[i] = true</code> is <code>true</code> for <strong>non</strong>-translational modes. If you need a mask that is <code>true</code> for <em>only</em> the 3 translational modes, simply invert the result of this function:</p><pre><code class="language-julia hljs">translation_mask!(non_trans_mask, pols, masses)
trans_mask = .!non_trans_mask</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/4b1e8d3ccdd5b6405fad69eb824496f3deaf8085/src/asr.jl#L110-L180">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../fourier_symmetries/">Symmetries in Q space »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 14 January 2026 15:04">Wednesday 14 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symmetries in Q space · AtomicSymmetries.jl Documentation</title><meta name="title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta property="og:title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta property="twitter:title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta name="description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="og:description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="twitter:description" content="Documentation for AtomicSymmetries.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AtomicSymmetries.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../acoustic_sum_rule/">Acoustic Sum Rule</a></li><li class="is-active"><a class="tocitem" href>Symmetries in Q space</a><ul class="internal"><li><a class="tocitem" href="#Fourier-transform"><span>Fourier transform</span></a></li><li><a class="tocitem" href="#Symmetries-in-Q-space"><span>Symmetries in Q space</span></a></li><li><a class="tocitem" href="#Enforcing-symmetries"><span>Enforcing symmetries</span></a></li><li><a class="tocitem" href="#Manipulating-q-points"><span>Manipulating q points</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symmetries in Q space</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symmetries in Q space</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/main/docs/src/fourier_symmetries.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symmetries-in-Fourier-space"><a class="docs-heading-anchor" href="#Symmetries-in-Fourier-space">Symmetries in Fourier space</a><a id="Symmetries-in-Fourier-space-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetries-in-Fourier-space" title="Permalink"></a></h1><p>From version 0.8, <code>AtomicSymmetries.jl</code> provided the possibility to apply symmetries to vector and matrices directly in Fourier space. This is implemented now for force-constant dynamical matrices and vectors (displacements, forces, ...).</p><p>A vector is transformed from real to q-space with the following convention:</p><p class="math-container">\[\tilde v_k(\vec q) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{-i 2\pi \vec R\cdot \vec q} v_k(\vec R)\]</p><p class="math-container">\[v_k(\vec R) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{i 2\pi \vec R\cdot \vec q} \tilde v_k(\vec q)\]</p><p>Note the sign of the Fourier and the normalization prefactor.  This convention allows for correctly transforming the matrices, however, it introduces a size inconsistency on the vectors. If we have a periodic vector in the cell, its <span>$q$</span> fourier transformed counterpart will be <span>$\sqrt {N_q}$</span> times the value in the primitive cell. So be carefull when extracting <span>$\Gamma$</span> point data from periodic vectors.</p><p>With this convention, we recover the standard rule for the matrices.</p><p class="math-container">\[\tilde \Phi_{ab}(\vec q) = \sum_{\vec R} e^{2\pi i \vec q\cdot \vec R}\Phi_{a;b + \vec R}\]</p><p class="math-container">\[\Phi_{ab} = \frac{1}{N_q} \sum_{\vec q}
\tilde\Phi_{ab}(\vec  q) e^{2i\pi \vec q\cdot[\vec R(a) - \vec R(b)]}\]</p><p>Note that these transformation of matrices and vector are consistent so that matrices and vector written as outer product can be consistently transformed</p><p class="math-container">\[\Phi(\vec R) = \sum_i\sum_{\vec R} \vec v_i(\vec R_1) \otimes \vec v_i(\vec R_1 + \vec R)\]</p><p class="math-container">\[\tilde \Phi(\vec q) = \sum_i \vec {\tilde v}_i(\vec q) \otimes \vec {\tilde v_i}(-\vec q)\]</p><p>Notably, this convention introduces two main properties that must be handled with care. The <span>$\Gamma$</span> value of the fourier transform is not the average over the supercell of the same quantity. If you want to obtain the average, you must divide by <span>$\sqrt {N_q}$</span> (the number of q-points). If the <code>R_lat</code> is not centered around zero, and the coordinates passed as <code>v_sc</code> are absolute values of positions, then the <span>$\Gamma$</span> value of the fourier transform will be shifted by a total translation which is the average of the translations of the supercell lattice vectors. This can be avoided by either removing the corner of the supercell from the positions before performing the fourier transform, by centering R<em>lat around 0, or by removing this translational average <em>a posteriori</em> using the method `shift</em>position_origin!`.</p><h2 id="Fourier-transform"><a class="docs-heading-anchor" href="#Fourier-transform">Fourier transform</a><a id="Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-transform" title="Permalink"></a></h2><p>The API to perform the fourier transform occur mainly with <code>vector_r2q!</code>, <code>vector_q2r!</code> which, respectively, trasform a vector from real to q space and vice-versa. Transformation of matrices occur with <code>matrix_r2q!</code>, <code>matrix_q2r!</code>. All these operations are inplace. The matrices are assumed in crystal coordinates, but in this case it should not matter.</p><p>To shift the origin for the fourier transformed absolute positions, use the method <code>shift_position_origin!</code> as</p><p>The detailed API calls are</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.vector_r2q!"><a class="docstring-binding" href="#AtomicSymmetries.vector_r2q!"><code>AtomicSymmetries.vector_r2q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vector_r2q!(
    v_q :: AbstractArray{Complex{T}, 3},
    v_sc :: AbstractMatrix{T},
    q_tot :: Matrix{T})
vector_r2q!(v_q :: AbstractArray{Complex{T}, 2},
    v_sc :: AbstractVector{T},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T}
) where {T &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>Fourier transform a vector from real space and q space.</p><p><span>$\displaystyle v_k(\vec q) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{-i 2\pi \vec R\cdot \vec q} v_k(\vec R)$</span></p><p>It works both on a single vector and on a series of vector.  NOTE: In the latter case, the number of configurations must be in the first column.  This is not standard,  but implemented in this way for performance reasons as it is the most convenient memory rapresentation for vectorizing the average calculation.</p><p>Notably, this convention introduces two main properties:</p><p>The <span>$\Gamma$</span> value of the fourier transform is not the average over the supercell of the same quantity. If you want to obtain the average, you must divide by √nq (the number of q-points).</p><p>If the <code>R_lat</code> is not centered around zero, and the coordinates passed as <code>v_sc</code> are absolute values of positions, then the <span>$\Gamma$</span> value of the fourier transform will be shifted by a total translation which is the average of the translations of the supercell lattice vectors.</p><p>To avoid this behaviour (which is wrong), you can use the option <code>absolute_positions</code>, which automatically rescales the <code>v_sc</code> to be coordinates relative to the respective cell origin identified by <code>R_lat</code>. Indeed, in this case, <code>R_lat</code> and <code>v_sc</code> must be of the same  units, and coordinate types (you cannot mix crystalline and cartesian).</p><p><strong>Parameters</strong></p><ul><li><code>v_q</code> : (n<em>configs, 3nat, nq)    The target vector in Fourier space. Optionally, n</em>configs could be omitted if transforming only 1 vector</li><li><code>v_sc</code> : (n<em>configs, 3*nat</em>sc)   The original vector in real space. Optionally, n_configs could be omitted if transforming only 1 vector</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau</code> : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat</code> : (3, nat_sc)   The origin coordinates of the supercell in which the atom is</li><li><code>absolute_positions</code> : Bool   If true [default false], removes from v<em>sc the value of R</em>lat.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/fourier_transform.jl#L2-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.vector_q2r!"><a class="docstring-binding" href="#AtomicSymmetries.vector_q2r!"><code>AtomicSymmetries.vector_q2r!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vector_q2r!(
    v_sc :: AbstractMatrix{T},
    v_q :: AbstractArray{Complex{T}, 3},
    q_tot :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T};
    absolute_positions :: Bool = false
    ) where {T &lt;: AbstractFloat, I &lt;: Integer}
function vector_q2r!(
    v_sc :: AbstractVector{T},
    v_q :: AbstractMatrix{Complex{T}},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T};
    absolute_positions :: Bool = false
) where {T &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>Fourier transform a vector from q space to real space.</p><p><span>$\displaystyle v_k(\vec R) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{+i 2\pi \vec R\cdot \vec q} v_k(\vec q)$</span></p><p>It can be applied both to a single vector and in an ensemble. NOTE: In the latter case, the configurations must be stored as the first index. This choice is made for performance reason in computing averages (exploiting vectorization).</p><p><strong>Parameters</strong></p><ul><li><code>v_sc</code> : (n<em>configs, 3*nat</em>sc)   The target vector in real space. Optionally, n_configs can be omitted</li><li><code>v_q</code> : (n<em>configs, nq, 3*nat)    The original vector in Fourier space. Optionally, n</em>configs can be omitted</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau : (nat_sc)</code>   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat : (3, nat_sc)</code>   The origin coordinates of the supercell in which the atom is</li><li><code>absolute_positions</code> : Bool   If true, add the absolute position of the cell to the transformed v_sc</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/fourier_transform.jl#L114-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.matrix_r2q!"><a class="docstring-binding" href="#AtomicSymmetries.matrix_r2q!"><code>AtomicSymmetries.matrix_r2q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">matrix_r2q!(
    matrix_q :: Array{Complex{T}, 3},
    matrix_r :: AbstractMatrix{T},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T})</code></pre><p>Fourier transform a matrix from real to q space</p><p class="math-container">\[M_{ab}(\vec q) = \sum_{\vec R} e^{2\pi i \vec q\cdot \vec R}\Phi_{a;b + \vec R}\]</p><p>Where <span>$\Phi_{ab}$</span> is the real space matrix, the <span>$b+\vec R$</span> indicates the corresponding atom in the supercell displaced by <span>$\vec R$</span>. </p><p><strong>Parameters</strong></p><ul><li><code>matrix_q</code> : (3nat, 3nat, nq)    The target matrix in Fourier space.</li><li><code>matrix_r</code> : (3<em>nat_sc, 3</em>nat)   The original matrix in real space (supercell)</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau</code> : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat</code> : (3, nat_sc)   The origin coordinates of the supercell in which the corresponding atom is</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/fourier_transform.jl#L218-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.matrix_q2r!"><a class="docstring-binding" href="#AtomicSymmetries.matrix_q2r!"><code>AtomicSymmetries.matrix_q2r!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">matrix_q2r!(
    matrix_r :: AbstractMatrix{T},
    matrix_q :: Array{Complex{T}, 3},
    q :: Matrix{T},
    itau :: Vector{Int},
    R_lat :: Matrix{T})</code></pre><p>Fourier transform a matrix from q space into r space</p><p><span>$\displaystyle \Phi_{ab} = \frac{1}{N_q} \sum_{\vec q} M_{ab}(\vec  q) e^{2i\pi \vec q\cdot[\vec R(a) - \vec R(b)]}$</span></p><p>Where <span>$\Phi_{ab}$</span> is the real space matrix, <span>$M_{ab}(\vec q)$</span> is the q space matrix.</p><p><strong>Parameters</strong></p><ul><li>matrix<em>r : (3*nat</em>sc, 3*nat)   The target matrix in real space (supercell). If the second dimension is 3nat_sc, we also apply the translations</li><li>matrix_q : (3nat, 3nat, nq)    The original matrix in Fourier space.</li><li>q_tot : (3, nq)   The list of q vectors</li><li>itau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li>R<em>lat : (3, nat</em>sc)   The origin coordinates of the supercell in which the corresponding atom is</li><li>translations : Vector{Vector{Int}}   The itau correspondance for each translational vector. Its size must be equal to the number of q point and   contain all possible translations. This can be obtained from the <code>get_translations</code> subroutine. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/fourier_transform.jl#L289-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.shift_position_origin!"><a class="docstring-binding" href="#AtomicSymmetries.shift_position_origin!"><code>AtomicSymmetries.shift_position_origin!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">shift_position_origin!(r_vector::AbstractVector{Complex{T}}, cell::AbstractMatrix{T}, R_lat::AbstractMatrix{T}; buffer) where T
shift_position_origin!(r_vectors::AbstractMatrix{Complex{T}}, cell::AbstractMatrix{T}, R_lat::AbstractMatrix{T}; buffer) where T</code></pre><p>Shifts a set of position vectors (<code>r_vector</code> or <code>r_vectors</code>) such that the average position (center of mass) of the reference lattice (<code>R_lat</code>) is moved to the origin. The function operates in-place. This can be employed after performing a Fourier Transform of absolute positions, to correct for non centered <code>R_lat</code>.</p><p>This is typically used to remove the lattice translation from displacement vectors before calculating quantities that are invariant to rigid body translations.</p><p>The average position vector of the reference lattice <span>$\mathbf{r}_{\text{avg}}$</span> is calculated in Cartesian coordinates, and then subtracted from the input vectors <span>$\mathbf{r}$</span>.</p><p class="math-container">\[\mathbf{r}_{\text{avg}} = \frac{1}{N_{\text{atoms}}} \sum_{k=1}^{N_{\text{atoms}}} \mathbf{r}_{\text{lat}, k}\]</p><p>The position vectors are then shifted:</p><p class="math-container">\[\mathbf{r}&#39; = \mathbf{r} - \mathbf{r}_{\text{avg}}\]</p><p><strong>Arguments</strong></p><ul><li><code>r_vector</code>/<code>r_vectors</code> : The position vector(s) (of type <code>Complex{T}</code>) to be shifted in-place. </li><li><code>cell</code> : The <span>$N_{dims} \times N_{dims}$</span> matrix defining the unit cell (lattice vectors). </li><li><code>R_lat</code> : The reference lattice positions (fractional/lattice coordinates, <span>$N_{dims} \times N_{atoms}$</span>) whose average position determines the shift. </li><li><code>buffer</code> : An optional buffer for temporary memory allocation (Bumer.jl)</li></ul><p><strong>Details on <code>r_vectors</code> Matrix Method</strong></p><p>The matrix method assumes that the input <code>r_vectors</code> has the dimensions <span>$(N_{\text{configs}}, N_{\text{dims}} \times N_{\text{atoms,v}})$</span>, where <span>$N_{\text{configs}}$</span> is the number of configurations, and <span>$N_{\text{atoms,v}}$</span> is the number of atoms in the vectors being shifted.</p><p>The shift is applied simultaneously to all configurations using broadcasting (<code>@views ... .-=</code>).</p><p><strong>Example</strong></p><p>An example of usage after the fourier transform</p><pre><code class="language-julia hljs"># Define positions_r as a n_configs, 3n_atoms_sc vector
# Perform the fourier transform in q space
# Here, we assume that R_lat and q_points are expressed in crystal coordinates.
# Otherwise, just pass the identity to the cell below.
vector_r2q!(positions_q, positions_r, q_points, itau, R_lat)

# Remove the translations
shift_position_origin!(positions_q, cell, R_lat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/fourier_transform.jl#L401-L449">source</a></section></details></article><h2 id="Symmetries-in-Q-space"><a class="docs-heading-anchor" href="#Symmetries-in-Q-space">Symmetries in Q space</a><a id="Symmetries-in-Q-space-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetries-in-Q-space" title="Permalink"></a></h2><p>The application of symmetries in Fourier space must also account how points in q space are mapped by the symmetry operations.</p><p>For this, the important information about how q points are related by symmetries needs to be computed and stored. This identification is performed by the helper function <code>get_irt_q!</code>, which identifies, for a given symmetry operation, the i-&gt;j mapping between q points. Q points mapped into themselves by the same set of symmetry operations form the socalled small-group of <span>$q$</span>, while the set of <span>$q$</span> points mapped by all the symmetries of a crystal is called the star of the <span>$q$</span> point. Due to time-inversion symmetry, the dynamical matrix must also satisfy the condition</p><p><span>$D(q) = D^\dagger(-q + G)$</span></p><p>therefore it is necessary also to keep track, for each q point, which one is the corresponding <span>$-q + G$</span> in the mesh. This mapping is computed by the helper function <code>get_minus_q!</code>. All these information needs to be stored when applying symmetries. Therefore we defined a new Symmetries struct that ihnerits from the <code>GenericSymmetries</code> called <code>SymmetriesQSpace</code>. Note that, to initialize the symmetries in q-space, we <strong>must</strong> use the symmetries object (<code>Symmetries</code>) evaluated in the primitive cell. The correct initialization of symmetries could be checked with the subroutine <code>check_symmetries</code>, which will spot if a different cell has been employed when initializing the symmetries.</p><p>Since the q points must be passed in crystal coordinates, it may be useful to get the reciprocal lattice, which can be done with <span>$get_reciprocal_lattice!$</span> (see section on crystal coordinates for the API)</p><h3 id="Application-of-symmetries"><a class="docs-heading-anchor" href="#Application-of-symmetries">Application of symmetries</a><a id="Application-of-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Application-of-symmetries" title="Permalink"></a></h3><p>Applying a symmetry means transforming a vector or a matrix (already in q-space) into a new vector (matrix). If the vector (matrix) is invariant under that transformation, then that transformation belong to the symmetry group.</p><p>Notably, the symmetries in the supercell are always the symmetries in the primitive cell times all possible translations operated by the lattice vectors compatible with the chosen supercell. On the contrary, the symmetries in q space are always only equal to the symmetries in the primitive cell. The reason is that translations are automatically incorporated in the q space representation by the block theorem:</p><p class="math-container">\[D(q, q&#39;) = D(q)\delta(q - q&#39;)\]</p><p>This means that applying each symmetry operation in <span>$q$</span> space is equivalent to averaging the result of the same symmetry operation in the supercell averaging among all possible translations.</p><p>The application of a symmetry in q space can be performed by considering how the force-constant matrix transform in real space under a symmetry operation <span>$S$</span>.</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = \sum_{\bm R} e^{2\pi i \bm q\cdot \bm R}S^\dagger\Phi_{S\bm a, S(\bm b + \bm R)}S\]</p><p>The transformation also changes which atoms are considered. However, we must be careful with the convention adopted for the Fourier transform. In fact, we have that <span>$\bm a$</span> and <span>$\bm b$</span> are the positions on the atom in the primitive cell considered. The vectors <span>$S\bm a$</span> and <span>$S(\bm b + \bm R)$</span> may not correspond to atoms in the primitive cell, but rather folded in the supercell.  To solve this issue, we need to define, for each symmetry operation, which atom in the primitive cell is mapped into which other atom in the primitive cell. This is indicated with <span>$s(a)$</span> and <span>$s(b)$</span>. Also, we need to consider what is the translation vector <span>$\bm t_{s,a}$</span> that brings the vector <span>$S\bm a$</span> inside the primitive cell. With this information, we can rewrite the transformation as</p><p class="math-container">\[\bm t_{s,a} = S\bm a - \bm{s(a)}\]</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = \sum_{\bm R} e^{2\pi i \bm q\cdot \bm R}S^\dagger\Phi_{s(a) + \bm t_{s,a}, s(b) + \bm t_{s, b} + S\bm R}S\]</p><p>Exploiting the translational invariance, we can remove the <span>$\bm t_{s,a}$</span> vector from the first index of the supercell force constant matrix, and rewrite the expression as</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = \sum_{\bm R} e^{2\pi i \bm q\cdot \bm R}S^\dagger\Phi_{s(a), s(b) + \bm t_{s, b} - \bm t_{s, a} + S\bm R}S\]</p><p>By defining <span>$\bm R&#39; = \bm t_{s, b} - \bm t_{s, a} + S\bm R$</span>, we can rewrite the summation in <span>$\bm R&#39;$</span> as</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = \sum_{\bm R&#39;} e^{2\pi i \bm q\cdot S^{-1} (\bm R&#39; + \bm t_{s,a} - \bm t_{s,b})}S^\dagger\Phi_{s(a), s(b) + \bm R&#39;}S\]</p><p>Since we work in crystal coordinates and reciprocal vectors, <span>$S^{-1}\neq S^\dagger$</span>. Therefore, we have</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = \sum_{\bm R&#39;} e^{2\pi i [(\bm S^{-1})^\dagger\bm q]\cdot(\bm R&#39; + \bm t_{s,a} - \bm t_{s,b})}S^\dagger\Phi_{s(a), s(b) + \bm R&#39;}S\]</p><p>Which is equivalent to the Fourier transform of the dynamical matrix at the transformed q-point <span>$(\bm S^{-1})^\dagger\bm q$</span>, times a phase factor. This is how symmetries operates in q space:</p><p class="math-container">\[\bm S_\text{recip} = \left(\bm S^{-1}\right)^\dagger\]</p><p class="math-container">\[S[\tilde\Phi_{ab}(\bm q)] = S^\dagger \tilde\Phi_{s(a)s(b)}(S_\text{recip}\bm q) S e^{2\pi i (S_\text{recip}\bm q)\cdot ( \bm t_{s,a} - \bm t_{s,b})}\]</p><p>Note that the <span>$S_\text{recip}q$</span> vector in the phase factor and in the dynamical matrix can be always folded back into the first Brilluin zone. In fact the dynamical matrix is periodic in the reciprocal vector, while the phase factor is multiplied by a direct lattice vector. Thus, by adding a reciprocal lattice vector <span>$\bm G$</span> to <span>$S_\text{recip}\bm q$</span>, the phase factor is multiplied by <span>$e^{2\pi i \bm G\cdot ( \bm t_{s,a} - \bm t_{s,b})}$</span>, which is always equal to 1.</p><p>This transformation for each q point is operated by the subroutine <code>apply_symmetry_matrixq!</code>. Both these function modify in-place the first argument, storing the result of the transformation there.  Note that, since symmetries are stored in crystalline components, both the vector and the matrix must be in crystalline components. This makes it also important that the <span>$\bm q$</span> points are provided in crystalline coordinates, to correctly compute the phase factor and the transformed <span>$S\bm q$</span>.</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.SymmetriesQSpace"><a class="docstring-binding" href="#AtomicSymmetries.SymmetriesQSpace"><code>AtomicSymmetries.SymmetriesQSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SymmetriesQSpace(symmetries :: Symmetries{T}, q_points :: AbstractMatrix{T}) :: SymmetriesQSpace{T} where T

struct SymmetriesQSpace{T} &lt;: GenericSymmetries where T
    symmetries :: Symmetries{T}
    irt_q :: Vector{Vector{Int}}
    minus_q_index :: Vector{Int}
end</code></pre><p>This structure contains the information to perform the symmetrization of a dynamical matrix directly in q space.</p><p><strong>Note that the <code>q_points</code> needs to be in crystal coordinates</strong>,</p><p>and the symmetries must be of the primitive cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.apply_symmetry_vectorq!"><a class="docstring-binding" href="#AtomicSymmetries.apply_symmetry_vectorq!"><code>AtomicSymmetries.apply_symmetry_vectorq!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_symmetry_vectorq!(target_vector :: AbstractMatrix{Complex{T}}, original_vector :: AbstractMatrix{Complex{T}}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, irt_q:: AbstractVector{Int})</code></pre><p>Apply the symmetry on the original vector in q space</p><p><strong>Parameters</strong></p><ul><li><code>target_vector</code> : The result (modified inplace) (3n x nq)</li><li><code>original_vector</code> : The original vector (3n x nq)</li><li><code>symmetry_operation</code> : The 3x3 symmetry </li><li><code>irt</code> : The atom-atom association by symmetry</li><li><code>irt_q</code> : The q-q association by symmetry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L86-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.apply_symmetry_matrixq!"><a class="docstring-binding" href="#AtomicSymmetries.apply_symmetry_matrixq!"><code>AtomicSymmetries.apply_symmetry_matrixq!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_symmetry_matrixq!(target_matrix :: AbstractArray{Complex{T}, 3},
    original_matrix :: AbstractArray{Complex{T}, 3},
    sym :: AbstractMatrix{U},
    irt :: AbstractVector{Int},
    irt_q :: AbstractVector{Int},
    unit_cell_translations :: AbstractMatrix{T},
    ; buffer = default_buffer()) where {T, U}</code></pre><p>Apply the symmetry on the matrix in q space This subroutine assumes the convention that the phase factor is for each supercell, not atoms. In other words, all the atoms coordinates are computed from the same origin of the supercell they are associated with.</p><p><strong>Parameters</strong></p><ul><li><code>target_vector</code> : The result (modified inplace) (3n x nq)</li><li><code>original_vector</code> : The original vector (3n x nq)</li><li><code>symmetry_operation</code> : The 3x3 symmetry </li><li><code>irt</code> : The atom-atom association by symmetry</li><li><code>irt_q</code> : The q-q association by symmetry</li><li><code>unit_cell_translations</code> : The translation vectors to move the transformed atom in the primitive cell</li><li><code>buffer</code> : The Bumper.jl buffer for caching memory allocations [Optional]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L122-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.get_irt_q!"><a class="docstring-binding" href="#AtomicSymmetries.get_irt_q!"><code>AtomicSymmetries.get_irt_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_irt_q!(irt_q :: AbstractVector{Int}, q_points :: AbstractVector{T}, sym_mat :: AbstractMatrix)</code></pre><p>Get the correspondance <span>$q&#39; = S_\text{recip} q$</span> on the provided q grid. Always assume everything is in crystal coordinates.</p><p>Note that in reciprocal space (crystal coordinates) the symmetry operation is the inverse transpose.</p><p class="math-container">\[S_\text{recip} = (S_\text{direct})^{-T}\]</p><p>The provided <code>sym_mat</code> is assumed to be in direct space.</p><p>This is needed for the correct application of the symmetries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L185-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.get_minus_q!"><a class="docstring-binding" href="#AtomicSymmetries.get_minus_q!"><code>AtomicSymmetries.get_minus_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_minus_q!(minus_q_index :: AbstractVector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer()) where T</code></pre><p>Identify for each q point what is the corresponding -q:</p><p><span>$\vec q \longrightarrow -\vec q + \vec G$</span></p><p>where <span>$\vec G$</span> is a reciprocal vector. Since this is done in crystal coordinates<span>$\vec G$</span> are all possible integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L256-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.check_symmetries"><a class="docstring-binding" href="#AtomicSymmetries.check_symmetries"><code>AtomicSymmetries.check_symmetries</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">check_symmetries(q_symmetries :: SymmetriesQSpace{T}, n_atoms :: Int) :: Bool</code></pre><p>Check if the q_symmetries has been correctly initialized in the primitive cell.</p><p>Essentially, this subroutine checks the atomic correspondance by symmetry and spots if there are atoms outside the primitive cell (whose index is above <code>n_atoms</code>).</p><p><strong>Parameters</strong></p><ul><li><code>q_symmetries</code> : The symmetries in q space</li><li><code>n_atoms</code> : The number of atoms in the primitive cell</li></ul><p><strong>Returns</strong></p><p><code>true</code> if no contraddiction have been detected, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L49-L67">source</a></section></details></article><h2 id="Enforcing-symmetries"><a class="docs-heading-anchor" href="#Enforcing-symmetries">Enforcing symmetries</a><a id="Enforcing-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Enforcing-symmetries" title="Permalink"></a></h2><p>One of the most useful operation to do is enforce a specific matrix or vector in q-space to satisfy a given symmetry group.</p><p>This can be implemented by applying the complete irreducible representation of the symmetry group. Symmetrization of an ent <code>\Phi</code> is obtained as</p><p><span>$\Phi = \frac{1}{N}\sum_{i=1}^N S_i(\Phi)$</span></p><p>where <span>$S_i$</span> is the symmetry operation. The two functions performing the symmetrization are <code>symmetrize_matrix_q!</code> and <code>symmetrize_vector_q!</code>. Also in this case, the dynamical matrix must be provided in crystalline coordinates.</p><p>To symmetrize vector and matrices already provided in cartesian coordinates, we must use the appropriate subroutines <code>symmetrize_vector_cartesian_q!</code> and <code>symmetrize_matrix_cartesian_q!</code>.  These two subroutines correctly convert the vector/matrix in crystal coordinates  before applying the symmetries, and then convert the symmetrized result back in cartesian space. They are the most used subroutines to perform symmetrization in q-space, the equivalent of <code>symmetrize_vector!</code> and <code>symmetrize_fc!</code> for real space.</p><p>Here the complete API</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.symmetrize_vector_q!"><a class="docstring-binding" href="#AtomicSymmetries.symmetrize_vector_q!"><code>AtomicSymmetries.symmetrize_vector_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetrize_vector_q!(target_gamma :: AbstractVector{T}, original_q :: AbstractArray{Complex{T}, 2}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T</code></pre><p>Impose the symmetrization of a vector in q space. Since the symmetrization also imposes translational symmetries, the result is always a vector only at gamma.</p><p>The symmetrized vector is supposed to be a displacement (so no translations are applied)</p><p>NOTE: The provided vector must be in crystal coordinates To symmetrize a vector incartesian coordinates, see the routine <code>symmetrize_vector_cartesian_q!</code>.</p><p><strong>Parameters</strong></p><ul><li><code>target_gamma</code> : The <code>n_at * n_dims</code> output symmetrized vector at <span>$\Gamma$</span></li><li><code>original_q</code> : The original vector in q-space of size <code>nat*n_dims, nq</code></li><li><code>symmetries</code> : The symmetry group</li><li><code>irt_q</code> : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from <code>get_irt_q!</code></li><li><code>gamma_index</code> : Specify which q vector is <span>$\Gamma$</span>. If not specified, it is assumed to be the first one</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L297-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.symmetrize_matrix_q!"><a class="docstring-binding" href="#AtomicSymmetries.symmetrize_matrix_q!"><code>AtomicSymmetries.symmetrize_matrix_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetrize_matrix_q!(target_q :: AbstractArray{Complex{T}, 3}, original_q :: AbstractArray{Complex{T}, 3}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T
symmetrize_matrix_q!(matrix_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T
symmetrize_matrix_q!(target_q :: AbstractArray{T, 3}, original_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T</code></pre><p>Impose the symmetrization of a dynamical matrix in q space. The matrix must be in crystal coordinates.</p><p><strong>Parameters</strong></p><ul><li><code>target_q</code> : The symmetrized matrix of size <code>n_modes, n_modes, nq</code> (modified in-place).</li><li><code>original_q</code> : The original matrix in q-space of size <code>n_modes, n_modes, nq</code>. It could be the same as target_q</li><li><code>symmetries</code> : The symmetry group</li><li><code>irt_q</code> : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from <code>get_irt_q!</code></li><li><code>unit_cell_translations</code> :: Vector{Matrix{T}} : The translations of the unit cell to bring back the atoms in the primitive cell after the symmetry operation. Each vector elements corresponds to one symmetry operation, then the matrix is a n<em>dims x n</em>atoms translation. This is usually the same as the content of <code>symmetries.unit_cell_translations</code>.</li><li><code>minus_q_index</code> : A vector containing for each <code>q</code> the corresponding <span>$\vec {q&#39;} = -\vec q + \vec G$</span>, where <span>$\vec G$</span> is a generic reciprocal lattice vector.</li><li><code>q_points</code> : The vector containing the actual q points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L398-L417">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.symmetrize_vector_cartesian_q!"><a class="docstring-binding" href="#AtomicSymmetries.symmetrize_vector_cartesian_q!"><code>AtomicSymmetries.symmetrize_vector_cartesian_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetrize_vector_cartesian_q!(vector_q_cart:: AbstractArray{Complex{T}, 2}, cell :: Matrix{T}, symmetries :: SymmetriesQSpace; buffer = default_buffer()) where {T}</code></pre><p>Perform the symmetrization of a vector (overwriting it) in cartesian coordinates. This is the go-to subroutine for performing symmetrization of vectors in q space.</p><p><strong>Parameters</strong></p><ul><li><code>vector_q_cart</code> : in-place symmetrize vector (q-space, cartesian coordinates)</li><li><code>cell</code> : 3x3 matrix of the primitive cell (column-based)</li><li><code>symmetries</code> : Symmetries in Q space</li><li><code>buffer</code> : Optional, Bumper stack buffer (caching)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L342-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AtomicSymmetries.symmetrize_matrix_cartesian_q!"><a class="docstring-binding" href="#AtomicSymmetries.symmetrize_matrix_cartesian_q!"><code>AtomicSymmetries.symmetrize_matrix_cartesian_q!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetrize_matrix_cartesian_q!(matrix_q :: AbstractArray{Complex{T}, 3}, cell :: Matrix{T}, q_symmetries :: SymmetriesQSpace; buffer=default_buffer()) where T</code></pre><p>Enforce the symmetries on the provided matrix (q-space), modifying it in-place. The provided matrix must be in Cartesian Coordinates.</p><p><strong>Parameters</strong></p><ul><li><code>matrix_q</code> : The matrix to be symmetrized. Size (nmodes, nmodes, nq)</li><li><code>cell</code> : The 3x3 primitive cell (column ordering)</li><li><code>q_symmetries</code> : The symmetry group (q-space)</li><li><code>buffer</code> : Optional, stack for Bumper to cache allocations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L479-L492">source</a></section></details></article><h2 id="Manipulating-q-points"><a class="docs-heading-anchor" href="#Manipulating-q-points">Manipulating q points</a><a id="Manipulating-q-points-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-q-points" title="Permalink"></a></h2><p>The fourier transform depends on the knowledge of few vectors: <code>q_points</code>, <code>itau</code>, and <code>R_lat</code> (evenutally <code>translations</code>, for inverse  fourier transform into a matrix).</p><p>All these properties can be evaluated from the core source. For example, to obtain the supercell to which the q points are commensurate,  we can use the <code>get_supercell</code> method as</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.get_supercell!"><a class="docstring-binding" href="#AtomicSymmetries.get_supercell!"><code>AtomicSymmetries.get_supercell!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_supercell(q_points::AbstractMatrix{T}, cell :: AbstractMatrix{T}) :: Vector{Int}
get_supercell(q_points::AbstractMatrix{T}) :: Vector{Int}
get_supercell!(supercell::AbstractVector{I}, q_points::AbstractMatrix{T}, cell :: AbstractMatrix{T}) where {T, I&lt;:Integer}
get_supercell!(supercell::AbstractVector{I}, q_points::AbstractMatrix{T}) where {T, I&lt;:Integer}</code></pre><p>Calculates the minimum supercell dimensions required to fold a set of commensurate wave vectors (<code>q_points</code>) back to the Gamma point (Γ) of the Brillouin zone.</p><p>The resulting supercell dimension <span>$</span>S_i<span>$</span> for each spatial direction is determined by the reciprocal of the smallest non-zero q-point component in that direction. For commensurate grids, this is mathematically equivalent to:</p><p class="math-container">\[S_i = \text{round} \left( \frac{1}{\min(|q_{i}|)} \right)\]</p><p>This function is primarily used when performing calculations in a real-space supercell that is commensurate with the input k-point (or q-point) grid.</p><p><strong>Arguments</strong></p><ul><li><code>q_points</code>: A 2D matrix where <strong>each column</strong> represents a q-point vector, and <strong>each row</strong> corresponds to a dimension (x, y, z).</li><li><code>supercell</code>: An pre-allocated integer vector to store the result (used by the <code>get_supercell!</code> in-place version).</li><li><code>cell</code> : The primitive cell. If not provided, the code assumes that q_points are    in fractional coordinates.</li></ul><p><strong>Important Note on Coordinates</strong></p><p>The <code>q_points</code> <strong>must</strong> be provided in <strong>crystal coordinates</strong> (fractional coordinates) if <code>cell</code> is not provided. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># 3 dimensions, 2 q-points
q_points = [0.5 0.0;
            0.0 0.5;
            0.0 0.25]

# The supercell dimensions required are based on (1/0.5, 1/0.5, 1/0.25).
supercell = get_supercell(q_points)
# Result: [2, 2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L549-L595">source</a></section></details></article><p>Analogously, we can get the translations <code>R_lat</code> as</p><article><details class="docstring" open="true"><summary id="AtomicSymmetries.get_R_lat!"><a class="docstring-binding" href="#AtomicSymmetries.get_R_lat!"><code>AtomicSymmetries.get_R_lat!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_R_lat!(R_lat :: Matrix{T}, primitive_coords :: Matrix{T}, supercell_coords :: Matrix{T})</code></pre><p>Get the <code>R_lat</code> parameter to perform the fourier transform.</p><p><strong>Parameters</strong></p><ul><li><code>R_lat</code> the result lattice vectors, modified inplace</li><li><code>primitive_coords</code> : The coordinates in the primitive cell</li><li><code>supercell_coords</code> : The coordinates in the supercell</li><li><code>itau</code> : The correspondence for each atom in the supercell with the respective atom in the primitive cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/0a10bc083131b03dbb4eb0e283f9b0f33ab8fb80/src/symmetrize_qspace.jl#L524-L536">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acoustic_sum_rule/">« Acoustic Sum Rule</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 8 January 2026 09:59">Thursday 8 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

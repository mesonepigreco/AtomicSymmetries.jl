<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symmetries in Q space · AtomicSymmetries.jl Documentation</title><meta name="title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta property="og:title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta property="twitter:title" content="Symmetries in Q space · AtomicSymmetries.jl Documentation"/><meta name="description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="og:description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="twitter:description" content="Documentation for AtomicSymmetries.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AtomicSymmetries.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Symmetries in Q space</a><ul class="internal"><li><a class="tocitem" href="#Fourier-transform"><span>Fourier transform</span></a></li><li><a class="tocitem" href="#Applications-of-symmetries-in-Fourier-space"><span>Applications of symmetries in Fourier space</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symmetries in Q space</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symmetries in Q space</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/main/docs/src/fourier_symmetries.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symmetries-in-Fourier-space"><a class="docs-heading-anchor" href="#Symmetries-in-Fourier-space">Symmetries in Fourier space</a><a id="Symmetries-in-Fourier-space-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetries-in-Fourier-space" title="Permalink"></a></h1><p>From version 0.8, <code>AtomicSymmetries.jl</code> provided the possibility to apply symmetries to vector and matrices directly in Fourier space. This is implemented now for force-constant dynamical matrices and vectors (displacements, forces, ...).</p><p>A vector is transformed from real to q-space with the following convention:</p><p><span>$\displaystyle \tilde v_k(\vec q) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{-i 2\pi \vec R\cdot \vec q} v_k(\vec R)$</span></p><p><span>$\displaystyle v_k(\vec R) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{i 2\pi \vec R\cdot \vec q} \tilde v_k(\vec q)$</span></p><p>Note the sign of the Fourier and the normalization prefactor. With this convention, we recover the standard rule for the matrices.</p><p><span>$\displaystyle \tilde \Phi_{ab}(\vec q) = \sum_{\vec R} e^{2\pi i \vec q\cdot \vec R}\Phi_{a;b + \vec R}$</span></p><p><span>$\displaystyle \Phi_{ab} = \frac{1}{N_q} \sum_{\vec q} \tilde\Phi_{ab}(\vec  q) e^{2i\pi \vec q\cdot[\vec R(a) - \vec R(b)]}$</span></p><p>Note that these transformation of matrices and vector are consistent so that matrices and vector written as outer product can be consistently transformed</p><p><span>$\displaystyle \Phi(\vec R) = \sum_i\sum_{\vec R} \vec v_i(\vec R_1) \otimes \vec v_i(\vec R_1 + \vec R)$</span></p><p><span>$\displaystyle \tilde \Phi(\vec q) = \sum_i \vec {\tilde v}_i(\vec q) \otimes \vec {\tilde v_i}(-\vec q)$</span></p><h2 id="Fourier-transform"><a class="docs-heading-anchor" href="#Fourier-transform">Fourier transform</a><a id="Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-transform" title="Permalink"></a></h2><p>The API to perform the fourier transform occur mainly with <code>vector_r2q!</code>, <code>vector_q2r!</code> which, respectively, trasform a vector from real to q space and vice-versa. Transformation of matrices occur with <code>matrix_r2q!</code>, <code>matrix_q2r!</code>. All these operations are inplace. The matrices are assumed in crystal coordinates, but in this case it should not matter.</p><p>The detailed API calls are</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.vector_r2q!" href="#AtomicSymmetries.vector_r2q!"><code>AtomicSymmetries.vector_r2q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_r2q!(
    v_q :: AbstractArray{Complex{T}, 3},
    v_sc :: AbstractMatrix{T},
    q_tot :: Matrix{T})
vector_r2q!(v_q :: AbstractArray{Complex{T}, 2},
    v_sc :: AbstractVector{T},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T}
) where {T &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>Fourier transform a vector from real space and q space.</p><p><span>$\displaystyle v_k(\vec q) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{-i 2\pi \vec R\cdot \vec q} v_k(\vec R)$</span></p><p>It works both on a single vector and on a series of vector.  NOTE: In the latter case, the number of configurations must be in the first column.  This is not standard,  but implemented in this way for performance reasons as it is the most convenient memory rapresentation for vectorizing the average calculation.</p><p><strong>Parameters</strong></p><ul><li><code>v_q</code> : (n<em>configs, 3nat, nq)    The target vector in Fourier space. Optionally, n</em>configs could be omitted if transforming only 1 vector</li><li><code>v_sc</code> : (n<em>configs, 3*nat</em>sc)   The original vector in real space. Optionally, n_configs could be omitted if transforming only 1 vector</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau</code> : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat</code> : (3, nat_sc)   The origin coordinates of the supercell in which the atom is</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/fourier_transform.jl#L2-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.vector_q2r!" href="#AtomicSymmetries.vector_q2r!"><code>AtomicSymmetries.vector_q2r!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_q2r!(
    v_sc :: AbstractMatrix{T},
    v_q :: AbstractArray{Complex{T}, 3},
    q_tot :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T}) where {T &lt;: AbstractFloat, I &lt;: Integer}
function vector_q2r!(
    v_sc :: AbstractVector{T},
    v_q :: AbstractMatrix{Complex{T}},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T}
) where {T &lt;: AbstractFloat, I &lt;: Integer}</code></pre><p>Fourier transform a vector from q space to real space.</p><p><span>$\displaystyle v_k(\vec R) = \frac{1}{\sqrt{N_q}} \sum_{R} e^{+i 2\pi \vec R\cdot \vec q} v_k(\vec q)$</span></p><p>It can be applied both to a single vector and in an ensemble. NOTE: In the latter case, the configurations must be stored as the first index. This choice is made for performance reason in computing averages (exploiting vectorization).</p><p><strong>Parameters</strong></p><ul><li><code>v_sc</code> : (n<em>configs, 3*nat</em>sc)   The target vector in real space. Optionally, n_configs can be omitted</li><li><code>v_q</code> : (n<em>configs, nq, 3*nat)    The original vector in Fourier space. Optionally, n</em>configs can be omitted</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau : (nat_sc)</code>   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat : (3, nat_sc)</code>   The origin coordinates of the supercell in which the atom is</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/fourier_transform.jl#L92-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.matrix_r2q!" href="#AtomicSymmetries.matrix_r2q!"><code>AtomicSymmetries.matrix_r2q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_r2q!(
    matrix_q :: Array{Complex{T}, 3},
    matrix_r :: AbstractMatrix{T},
    q :: Matrix{T},
    itau :: Vector{I},
    R_lat :: Matrix{T})</code></pre><p>Fourier transform a matrix from real to q space</p><p class="math-container">\[M_{ab}(\vec q) = \sum_{\vec R} e^{-2\pi i \vec q\cdot \vec R}\Phi_{a;b + \vec R}\]</p><p>Where <span>$\Phi_{ab}$</span> is the real space matrix, the <span>$b+\vec R$</span> indicates the corresponding atom in the supercell displaced by <span>$\vec R$</span>. </p><p><strong>Parameters</strong></p><ul><li><code>matrix_q</code> : (3nat, 3nat, nq)    The target matrix in Fourier space.</li><li><code>matrix_r</code> : (3<em>nat_sc, 3</em>nat)   The original matrix in real space (supercell)</li><li><code>q_tot</code> : (3, nq)   The list of q vectors</li><li><code>itau</code> : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li><code>R_lat</code> : (3, nat_sc)   The origin coordinates of the supercell in which the corresponding atom is</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/fourier_transform.jl#L178-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.matrix_q2r!" href="#AtomicSymmetries.matrix_q2r!"><code>AtomicSymmetries.matrix_q2r!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_q2r!(
    matrix_r :: AbstractMatrix{T},
    matrix_q :: Array{Complex{T}, 3},
    q :: Matrix{T},
    itau :: Vector{Int},
    R_lat :: Matrix{T})</code></pre><p>Fourier transform a matrix from q space into r space</p><p><span>$\displaystyle \Phi_{ab} = \frac{1}{N_q} \sum_{\vec q} M_{ab}(\vec  q) e^{2i\pi \vec q\cdot[\vec R(a) - \vec R(b)]}$</span></p><p>Where <span>$\Phi_{ab}$</span> is the real space matrix, <span>$M_{ab}(\vec q)$</span> is the q space matrix.</p><p><strong>Parameters</strong></p><ul><li>matrix<em>r : (3*nat</em>sc, 3*nat)   The target matrix in real space (supercell). If the second dimension is 3nat_sc, we also apply the translations</li><li>matrix_q : (3nat, 3nat, nq)    The original matrix in Fourier space.</li><li>q_tot : (3, nq)   The list of q vectors</li><li>itau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.</li><li>R<em>lat : (3, nat</em>sc)   The origin coordinates of the supercell in which the corresponding atom is</li><li>translations : Vector{Vector{Int}}   The itau correspondance for each translational vector. Its size must be equal to the number of q point and   contain all possible translations. This can be obtained from the <code>get_translations</code> subroutine. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/fourier_transform.jl#L249-L284">source</a></section></article><h2 id="Applications-of-symmetries-in-Fourier-space"><a class="docs-heading-anchor" href="#Applications-of-symmetries-in-Fourier-space">Applications of symmetries in Fourier space</a><a id="Applications-of-symmetries-in-Fourier-space-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-symmetries-in-Fourier-space" title="Permalink"></a></h2><p>The application of symmetries in Fourier space must also account how points in q space are mapped by the symmetry operations.</p><p>For this, the important information about how q points are related by symmetries needs to be computed and stored. This identification is performed by the helper function <code>get_irt_q!</code>, which identifies, for a given symmetry operation, the i-&gt;j mapping between q points. Q points mapped into themselves by the same set of symmetry operations form the socalled small-group of <span>$q$</span>, while the set of <span>$q$</span> points mapped by all the symmetries of a crystal is called the star of the <span>$q$</span> point. Due to time-inversion symmetry, the dynamical matrix must also satisfy the condition</p><p><span>$D(q) = D^\dagger(-q + G)$</span></p><p>therefore it is necessary also to keep track, for each q point, which one is the corresponding <span>$-q + G$</span> in the mesh. This mapping is computed by the helper function <code>get_minus_q!</code>. All these information needs to be stored when applying symmetries. Therefore we defined a new Symmetries struct that ihnerits from the <code>GenericSymmetries</code> called <code>SymmetriesQSpace</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.SymmetriesQSpace" href="#AtomicSymmetries.SymmetriesQSpace"><code>AtomicSymmetries.SymmetriesQSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetriesQSpace(symmetries :: Symmetries{T}, q_points :: AbstractMatrix{T}) :: SymmetriesQSpace{T} where T

struct SymmetriesQSpace{T} &lt;: GenericSymmetries where T
    symmetries :: Symmetries{T}
    irt_q :: Vector{Vector{Int}}
    minus_q_index :: Vector{Int}
end</code></pre><p>This structure contains the information to perform the symmetrization of a dynamical matrix directly in q space. Note that the <code>q_points</code> needs to be in crystal coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_irt_q!" href="#AtomicSymmetries.get_irt_q!"><code>AtomicSymmetries.get_irt_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_irt_q!(irt_q :: AbstractVector{Int}, q_points :: AbstractVector{T}, sym_mat :: AbstractMatrix)</code></pre><p>Get the correspondance q&#39; = Sq on the provided q grid. Always assume everything is in crystal coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_minus_q!" href="#AtomicSymmetries.get_minus_q!"><code>AtomicSymmetries.get_minus_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_minus_q!(minus_q_index :: AbstractVector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer()) where T</code></pre><p>Identify for each q point what is the corresponding -q:</p><p><span>$\vec q \longrightarrow -\vec q + \vec G$</span></p><p>where <span>$\vec G$</span> is a reciprocal vector. Since this is done in crystal coordinates<span>$\vec G$</span> are all possible integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L155-L165">source</a></section></article><h3 id="Application-of-symmetries"><a class="docs-heading-anchor" href="#Application-of-symmetries">Application of symmetries</a><a id="Application-of-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Application-of-symmetries" title="Permalink"></a></h3><p>Applying a symmetry means transforming a vector or a matrix (already in q-space) into a new vector (matrix). If the vector (matrix) is invariant under that transformation, then that transformation belong to the symmetry group.</p><p>To apply the symmetry to a matrix we use the <code>apply_symmetry_vectorq!</code>. For the matrix, we use <code>apply_symmetry_matrixq!</code>. Both these function modify in-place the first argument, storing the result of the transformation there. Note that, since symmetries are stored in crystalline components, both the vector and the matrix must be in crystalline components. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.apply_symmetry_vectorq!" href="#AtomicSymmetries.apply_symmetry_vectorq!"><code>AtomicSymmetries.apply_symmetry_vectorq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_symmetry_vectorq!(target_vector :: AbstractMatrix{Complex{T}}, original_vector :: AbstractMatrix{Complex{T}}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, irt_q:: AbstractVector{Int})</code></pre><p>Apply the symmetry on the original vector in q space</p><p><strong>Parameters</strong></p><ul><li><code>target_vector</code> : The result (modified inplace) (3n x nq)</li><li><code>original_vector</code> : The original vector (3n x nq)</li><li><code>symmetry_operation</code> : The 3x3 symmetry </li><li><code>irt</code> : The atom-atom association by symmetry</li><li><code>irt_q</code> : The q-q association by symmetry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.apply_symmetry_matrixq!" href="#AtomicSymmetries.apply_symmetry_matrixq!"><code>AtomicSymmetries.apply_symmetry_matrixq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_symmetry_matrixq!(target_matrix :: AbstractArray{Complex{T}, 3}, original_matrix :: AbstractArray{Complex{T}, 3}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer())</code></pre><p>Apply the symmetry on the matrix in q space This subroutine assumes the convention that the phase factor is for each supercell, not atoms. In other words, all the atoms coordinates are computed from the same origin of the supercell they are associated with.</p><p><strong>Parameters</strong></p><ul><li><code>target_vector</code> : The result (modified inplace) (3n x nq)</li><li><code>original_vector</code> : The original vector (3n x nq)</li><li><code>symmetry_operation</code> : The 3x3 symmetry </li><li><code>irt</code> : The atom-atom association by symmetry</li><li><code>irt_q</code> : The q-q association by symmetry</li><li><code>buffer</code> : The Bumper.jl buffer for caching memory allocations [Optional]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L71-L87">source</a></section></article><h3 id="Enforcing-symmetries"><a class="docs-heading-anchor" href="#Enforcing-symmetries">Enforcing symmetries</a><a id="Enforcing-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Enforcing-symmetries" title="Permalink"></a></h3><p>One of the most useful operation to do is enforce a specific matrix or vector in q-space to satisfy a given symmetry group.</p><p>This can be implemented by applying the complete irreducible representation of the symmetry group. Symmetrization of an ent <code>\phi</code> is obtained as</p><p><span>$\Phi = \frac{1}{N}\sum_{i=1}^N S_i(\phi)$</span></p><p>where <span>$S_i$</span> is the symmetry operation. The two functions performing the symmetrization are <code>symmetrize_matrix_q!</code> and <code>symmetrize_vector_q!</code>. Also in this case, the dynamical matrix must be provided in crystalline coordinates.</p><p>To symmetrize vector and matrices already provided in cartesian coordinates, we must use the appropriate subroutines <code>symmetrize_vector_cartesian_q!</code> and <code>symmetrize_matrix_cartesian_q!</code>.  These two subroutines correctly convert the vector/matrix in crystal coordinates  before applying the symmetries, and then convert the symmetrized result back in cartesian space. They are the most used subroutines to perform symmetrization in q-space, the equivalent of <code>symmetrize_vector!</code> and <code>symmetrize_fc!</code> for real space.</p><p>Here the complete API</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.symmetrize_vector_q!" href="#AtomicSymmetries.symmetrize_vector_q!"><code>AtomicSymmetries.symmetrize_vector_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_vector_q!(target_gamma :: AbstractVector{T}, original_q :: AbstractArray{Complex{T}, 2}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T</code></pre><p>Impose the symmetrization of a vector in q space. Since the symmetrization also imposes translational symmetries, the result is always a vector only at gamma.</p><p>The symmetrized vector is supposed to be a displacement (so no translations are applied)</p><p>NOTE: The provided vector must be in crystal coordinates To symmetrize a vector incartesian coordinates, see the routine <code>symmetrize_vector_cartesian_q!</code>.</p><p><strong>Parameters</strong></p><ul><li><code>target_gamma</code> : The <code>n_at * n_dims</code> output symmetrized vector at <span>$\Gamma$</span></li><li><code>original_q</code> : The original vector in q-space of size <code>nat*n_dims, nq</code></li><li><code>symmetries</code> : The symmetry group</li><li><code>irt_q</code> : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from <code>get_irt_q!</code></li><li><code>gamma_index</code> : Specify which q vector is <span>$\Gamma$</span>. If not specified, it is assumed to be the first one</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L197-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.symmetrize_matrix_q!" href="#AtomicSymmetries.symmetrize_matrix_q!"><code>AtomicSymmetries.symmetrize_matrix_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_matrix_q!(target_q :: AbstractArray{Complex{T}, 3}, original_q :: AbstractArray{Complex{T}, 3}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T
symmetrize_matrix_q!(matrix_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T
symmetrize_matrix_q!(target_q :: AbstractArray{T, 3}, original_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T</code></pre><p>Impose the symmetrization of a dynamical matrix in q space. The matrix must be in crystal coordinates.</p><p><strong>Parameters</strong></p><ul><li><code>target_q</code> : The symmetrized matrix of size <code>n_modes, n_modes, nq</code> (modified in-place).</li><li><code>original_q</code> : The original matrix in q-space of size <code>n_modes, n_modes, nq</code>. It could be the same as target_q</li><li><code>symmetries</code> : The symmetry group</li><li><code>irt_q</code> : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from <code>get_irt_q!</code></li><li><code>minus_q_index</code> : A vector containing for each <code>q</code> the corresponding <span>$\vec {q&#39;} = -\vec q + \vec G$</span>, where <span>$\vec G$</span> is a generic reciprocal lattice vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L290-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.symmetrize_vector_cartesian_q!" href="#AtomicSymmetries.symmetrize_vector_cartesian_q!"><code>AtomicSymmetries.symmetrize_vector_cartesian_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_vector_cartesian_q!(vector_q_cart:: AbstractArray{Complex{T}, 2}, cell :: Matrix{T}, symmetries :: SymmetriesQSpace; buffer = default_buffer()) where {T}</code></pre><p>Perform the symmetrization of a vector (overwriting it) in cartesian coordinates. This is the go-to subroutine for performing symmetrization of vectors in q space.</p><p><strong>Parameters</strong></p><ul><li><code>vector_q_cart</code> : in-place symmetrize vector (q-space, cartesian coordinates)</li><li><code>cell</code> : 3x3 matrix of the primitive cell (column-based)</li><li><code>symmetries</code> : Symmetries in Q space</li><li><code>buffer</code> : Optional, Bumper stack buffer (caching)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.symmetrize_matrix_cartesian_q!" href="#AtomicSymmetries.symmetrize_matrix_cartesian_q!"><code>AtomicSymmetries.symmetrize_matrix_cartesian_q!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_matrix_cartesian_q!(matrix_q :: AbstractArray{Complex{T}, 3}, cell :: Matrix{T}, q_symmetries :: SymmetriesQSpace; buffer=default_buffer()) where T</code></pre><p>Enforce the symmetries on the provided matrix (q-space), modifying it in-place. The provided matrix must be in Cartesian Coordinates.</p><p><strong>Parameters</strong></p><ul><li><code>matrix_q</code> : The matrix to be symmetrized. Size (nmodes, nmodes, nq)</li><li><code>cell</code> : The 3x3 primitive cell (column ordering)</li><li><code>q_symmetries</code> : The symmetry group (q-space)</li><li><code>buffer</code> : Optional, stack for Bumper to cache allocations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/d6234948d05bcc5ae2762100c84c5cd2564024ff/src/symmetrize_qspace.jl#L364-L377">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 15 September 2025 12:35">Monday 15 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

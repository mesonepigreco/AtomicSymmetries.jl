var documenterSearchIndex = {"docs":
[{"location":"fourier_symmetries/#Symmetries-in-Fourier-space","page":"Symmetries in Q space","title":"Symmetries in Fourier space","text":"From version 0.8, AtomicSymmetries.jl provided the possibility to apply symmetries to vector and matrices directly in Fourier space. This is implemented now for force-constant dynamical matrices and vectors (displacements, forces, ...).\n\nA vector is transformed from real to q-space with the following convention:\n\ntilde v_k(vec q) = frac1sqrtN_q sum_R e^-i 2pi vec Rcdot vec q v_k(vec R)\n\nv_k(vec R) = frac1sqrtN_q sum_R e^i 2pi vec Rcdot vec q tilde v_k(vec q)\n\nNote the sign of the Fourier and the normalization prefactor.  This convention allows for correctly transforming the matrices, however, it introduces a size inconsistency on the vectors. If we have a periodic vector in the cell, its q fourier transformed counterpart will be sqrt N_q times the value in the primitive cell. So be carefull when extracting Gamma point data from periodic vectors.\n\nWith this convention, we recover the standard rule for the matrices.\n\ntilde Phi_ab(vec q) = sum_vec R e^2pi i vec qcdot vec RPhi_ab + vec R\n\nPhi_ab = frac1N_q sum_vec q\ntildePhi_ab(vec  q) e^2ipi vec qcdotvec R(a) - vec R(b)\n\nNote that these transformation of matrices and vector are consistent so that matrices and vector written as outer product can be consistently transformed\n\nPhi(vec R) = sum_isum_vec R vec v_i(vec R_1) otimes vec v_i(vec R_1 + vec R)\n\ntilde Phi(vec q) = sum_i vec tilde v_i(vec q) otimes vec tilde v_i(-vec q)\n\nNotably, this convention introduces two main properties that must be handled with care. The Gamma value of the fourier transform is not the average over the supercell of the same quantity. If you want to obtain the average, you must divide by sqrt N_q (the number of q-points). If the R_lat is not centered around zero, and the coordinates passed as v_sc are absolute values of positions, then the Gamma value of the fourier transform will be shifted by a total translation which is the average of the translations of the supercell lattice vectors. This can be avoided by either removing the corner of the supercell from the positions before performing the fourier transform, by centering Rlat around 0, or by removing this translational average a posteriori using the method `shiftposition_origin!`.","category":"section"},{"location":"fourier_symmetries/#Fourier-transform","page":"Symmetries in Q space","title":"Fourier transform","text":"The API to perform the fourier transform occur mainly with vector_r2q!, vector_q2r! which, respectively, trasform a vector from real to q space and vice-versa. Transformation of matrices occur with matrix_r2q!, matrix_q2r!. All these operations are inplace. The matrices are assumed in crystal coordinates, but in this case it should not matter.\n\nTo shift the origin for the fourier transformed absolute positions, use the method shift_position_origin! as\n\nThe detailed API calls are","category":"section"},{"location":"fourier_symmetries/#Symmetries-in-Q-space","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"The application of symmetries in Fourier space must also account how points in q space are mapped by the symmetry operations.\n\nFor this, the important information about how q points are related by symmetries needs to be computed and stored. This identification is performed by the helper function get_irt_q!, which identifies, for a given symmetry operation, the i->j mapping between q points. Q points mapped into themselves by the same set of symmetry operations form the socalled small-group of q, while the set of q points mapped by all the symmetries of a crystal is called the star of the q point. Due to time-inversion symmetry, the dynamical matrix must also satisfy the condition\n\nD(q) = D^dagger(-q + G)\n\ntherefore it is necessary also to keep track, for each q point, which one is the corresponding -q + G in the mesh. This mapping is computed by the helper function get_minus_q!. All these information needs to be stored when applying symmetries. Therefore we defined a new Symmetries struct that ihnerits from the GenericSymmetries called SymmetriesQSpace. Note that, to initialize the symmetries in q-space, we must use the symmetries object (Symmetries) evaluated in the primitive cell. The correct initialization of symmetries could be checked with the subroutine check_symmetries, which will spot if a different cell has been employed when initializing the symmetries.\n\nSince the q points must be passed in crystal coordinates, it may be useful to get the reciprocal lattice, which can be done with get_reciprocal_lattice (see section on crystal coordinates for the API)","category":"section"},{"location":"fourier_symmetries/#Application-of-symmetries","page":"Symmetries in Q space","title":"Application of symmetries","text":"Applying a symmetry means transforming a vector or a matrix (already in q-space) into a new vector (matrix). If the vector (matrix) is invariant under that transformation, then that transformation belong to the symmetry group.\n\nNotably, the symmetries in the supercell are always the symmetries in the primitive cell times all possible translations operated by the lattice vectors compatible with the chosen supercell. On the contrary, the symmetries in q space are always only equal to the symmetries in the primitive cell. The reason is that translations are automatically incorporated in the q space representation by the block theorem:\n\nD(q q) = D(q)delta(q - q)\n\nThis means that applying each symmetry operation in q space is equivalent to averaging the result of the same symmetry operation in the supercell averaging among all possible translations.\n\nThe application of a symmetry in q space can be performed by considering how the force-constant matrix transform in real space under a symmetry operation S.\n\nStildePhi_ab(bm q) = sum_bm R e^2pi i bm qcdot bm RS^daggerPhi_Sbm a S(bm b + bm R)S\n\nThe transformation also changes which atoms are considered. However, we must be careful with the convention adopted for the Fourier transform. In fact, we have that bm a and bm b are the positions on the atom in the primitive cell considered. The vectors Sbm a and S(bm b + bm R) may not correspond to atoms in the primitive cell, but rather folded in the supercell.  To solve this issue, we need to define, for each symmetry operation, which atom in the primitive cell is mapped into which other atom in the primitive cell. This is indicated with s(a) and s(b). Also, we need to consider what is the translation vector bm t_sa that brings the vector Sbm a inside the primitive cell. With this information, we can rewrite the transformation as\n\nbm t_sa = Sbm a - bms(a)\n\nStildePhi_ab(bm q) = sum_bm R e^2pi i bm qcdot bm RS^daggerPhi_s(a) + bm t_sa s(b) + bm t_s b + Sbm RS\n\nExploiting the translational invariance, we can remove the bm t_sa vector from the first index of the supercell force constant matrix, and rewrite the expression as\n\nStildePhi_ab(bm q) = sum_bm R e^2pi i bm qcdot bm RS^daggerPhi_s(a) s(b) + bm t_s b - bm t_s a + Sbm RS\n\nBy defining bm R = bm t_s b - bm t_s a + Sbm R, we can rewrite the summation in bm R as\n\nStildePhi_ab(bm q) = sum_bm R e^2pi i bm qcdot S^-1 (bm R + bm t_sa - bm t_sb)S^daggerPhi_s(a) s(b) + bm RS\n\nSince we work in crystal coordinates and reciprocal vectors, S^-1neq S^dagger. Therefore, we have\n\nStildePhi_ab(bm q) = sum_bm R e^2pi i (bm S^-1)^daggerbm qcdot(bm R + bm t_sa - bm t_sb)S^daggerPhi_s(a) s(b) + bm RS\n\nWhich is equivalent to the Fourier transform of the dynamical matrix at the transformed q-point (bm S^-1)^daggerbm q, times a phase factor. This is how symmetries operates in q space:\n\nbm S_textrecip = left(bm S^-1right)^dagger\n\nStildePhi_ab(bm q) = S^dagger tildePhi_s(a)s(b)(S_textrecipbm q) S e^2pi i (S_textrecipbm q)cdot ( bm t_sa - bm t_sb)\n\nNote that the S_textrecipq vector in the phase factor and in the dynamical matrix can be always folded back into the first Brilluin zone. In fact the dynamical matrix is periodic in the reciprocal vector, while the phase factor is multiplied by a direct lattice vector. Thus, by adding a reciprocal lattice vector bm G to S_textrecipbm q, the phase factor is multiplied by e^2pi i bm Gcdot ( bm t_sa - bm t_sb), which is always equal to 1.\n\nThis transformation for each q point is operated by the subroutine apply_symmetry_matrixq!. Both these function modify in-place the first argument, storing the result of the transformation there.  Note that, since symmetries are stored in crystalline components, both the vector and the matrix must be in crystalline components. This makes it also important that the bm q points are provided in crystalline coordinates, to correctly compute the phase factor and the transformed Sbm q.","category":"section"},{"location":"fourier_symmetries/#Enforcing-symmetries","page":"Symmetries in Q space","title":"Enforcing symmetries","text":"One of the most useful operation to do is enforce a specific matrix or vector in q-space to satisfy a given symmetry group.\n\nThis can be implemented by applying the complete irreducible representation of the symmetry group. Symmetrization of an ent \\Phi is obtained as\n\nPhi = frac1Nsum_i=1^N S_i(Phi)\n\nwhere S_i is the symmetry operation. The two functions performing the symmetrization are symmetrize_matrix_q! and symmetrize_vector_q!. Also in this case, the dynamical matrix must be provided in crystalline coordinates.\n\nTo symmetrize vector and matrices already provided in cartesian coordinates, we must use the appropriate subroutines symmetrize_vector_cartesian_q! and symmetrize_matrix_cartesian_q!.  These two subroutines correctly convert the vector/matrix in crystal coordinates  before applying the symmetries, and then convert the symmetrized result back in cartesian space. They are the most used subroutines to perform symmetrization in q-space, the equivalent of symmetrize_vector! and symmetrize_fc! for real space.\n\nThe Hermitianity is not automatically imposed by the symmetrization procedure. This allows to symmetrize matrices that are not necessarily hermitian, for example, the cross correlation matrices between different quantities. Hermitianity and time-reversal symmetry can be imposed with the subroutine impose_hermitianity_q!, which enforces the condition. The time-reversal symmetry corresponds to the condition that the original matrix in real space is real-valued.\n\nHere the complete API","category":"section"},{"location":"fourier_symmetries/#Manipulating-q-points","page":"Symmetries in Q space","title":"Manipulating q points","text":"The fourier transform depends on the knowledge of few vectors: q_points, itau, and R_lat (evenutally translations, for inverse  fourier transform into a matrix).\n\nAll these properties can be evaluated from the core source. For example, to obtain the supercell to which the q points are commensurate,  we can use the get_supercell method as\n\nAnalogously, we can get the translations R_lat as","category":"section"},{"location":"fourier_symmetries/#AtomicSymmetries.vector_r2q!","page":"Symmetries in Q space","title":"AtomicSymmetries.vector_r2q!","text":"vector_r2q!(\n    v_q :: AbstractArray{Complex{T}, 3},\n    v_sc :: AbstractMatrix{T},\n    q_tot :: Matrix{T})\nvector_r2q!(v_q :: AbstractArray{Complex{T}, 2},\n    v_sc :: AbstractVector{T},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T}\n) where {T <: AbstractFloat, I <: Integer}\n\nFourier transform a vector from real space and q space.\n\ndisplaystyle v_k(vec q) = frac1sqrtN_q sum_R e^-i 2pi vec Rcdot vec q v_k(vec R)\n\nIt works both on a single vector and on a series of vector.  NOTE: In the latter case, the number of configurations must be in the first column.  This is not standard,  but implemented in this way for performance reasons as it is the most convenient memory rapresentation for vectorizing the average calculation.\n\nNotably, this convention introduces two main properties:\n\nThe Gamma value of the fourier transform is not the average over the supercell of the same quantity. If you want to obtain the average, you must divide by √nq (the number of q-points).\n\nIf the R_lat is not centered around zero, and the coordinates passed as v_sc are absolute values of positions, then the Gamma value of the fourier transform will be shifted by a total translation which is the average of the translations of the supercell lattice vectors.\n\nTo avoid this behaviour (which is wrong), you can use the option absolute_positions, which automatically rescales the v_sc to be coordinates relative to the respective cell origin identified by R_lat. Indeed, in this case, R_lat and v_sc must be of the same  units, and coordinate types (you cannot mix crystalline and cartesian).\n\nParameters\n\nv_q : (nconfigs, 3nat, nq)    The target vector in Fourier space. Optionally, nconfigs could be omitted if transforming only 1 vector\nv_sc : (nconfigs, 3*natsc)   The original vector in real space. Optionally, n_configs could be omitted if transforming only 1 vector\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nR_lat : (3, nat_sc)   The origin coordinates of the supercell in which the atom is\nabsolute_positions : Bool   If true [default false], removes from vsc the value of Rlat.\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.vector_q2r!","page":"Symmetries in Q space","title":"AtomicSymmetries.vector_q2r!","text":"vector_q2r!(\n    v_sc :: AbstractMatrix{T},\n    v_q :: AbstractArray{Complex{T}, 3},\n    q_tot :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T};\n    absolute_positions :: Bool = false\n    ) where {T <: AbstractFloat, I <: Integer}\nfunction vector_q2r!(\n    v_sc :: AbstractVector{T},\n    v_q :: AbstractMatrix{Complex{T}},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T};\n    absolute_positions :: Bool = false\n) where {T <: AbstractFloat, I <: Integer}\n\nFourier transform a vector from q space to real space.\n\ndisplaystyle v_k(vec R) = frac1sqrtN_q sum_R e^+i 2pi vec Rcdot vec q v_k(vec q)\n\nIt can be applied both to a single vector and in an ensemble. NOTE: In the latter case, the configurations must be stored as the first index. This choice is made for performance reason in computing averages (exploiting vectorization).\n\nParameters\n\nv_sc : (nconfigs, 3*natsc)   The target vector in real space. Optionally, n_configs can be omitted\nv_q : (nconfigs, nq, 3*nat)    The original vector in Fourier space. Optionally, nconfigs can be omitted\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nR_lat : (3, nat_sc)   The origin coordinates of the supercell in which the atom is\nabsolute_positions : Bool   If true, add the absolute position of the cell to the transformed v_sc\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.matrix_r2q!","page":"Symmetries in Q space","title":"AtomicSymmetries.matrix_r2q!","text":"matrix_r2q!(\n    matrix_q :: Array{Complex{T}, 3},\n    matrix_r :: AbstractMatrix{T},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T})\n\nFourier transform a matrix from real to q space\n\nM_ab(vec q) = sum_vec R e^2pi i vec qcdot vec RPhi_ab + vec R\n\nWhere Phi_ab is the real space matrix, the b+vec R indicates the corresponding atom in the supercell displaced by vec R. \n\nParameters\n\nmatrix_q : (3nat, 3nat, nq)    The target matrix in Fourier space.\nmatrix_r : (3nat_sc, 3nat)   The original matrix in real space (supercell)\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nR_lat : (3, nat_sc)   The origin coordinates of the supercell in which the corresponding atom is\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.matrix_q2r!","page":"Symmetries in Q space","title":"AtomicSymmetries.matrix_q2r!","text":"matrix_q2r!(\n    matrix_r :: AbstractMatrix{T},\n    matrix_q :: Array{Complex{T}, 3},\n    q :: Matrix{T},\n    itau :: Vector{Int},\n    R_lat :: Matrix{T})\n\nFourier transform a matrix from q space into r space\n\ndisplaystyle Phi_ab = frac1N_q sum_vec q M_ab(vec  q) e^2ipi vec qcdotvec R(a) - vec R(b)\n\nWhere Phi_ab is the real space matrix, M_ab(vec q) is the q space matrix.\n\nParameters\n\nmatrixr : (3*natsc, 3*nat)   The target matrix in real space (supercell). If the second dimension is 3nat_sc, we also apply the translations\nmatrix_q : (3nat, 3nat, nq)    The original matrix in Fourier space.\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nRlat : (3, natsc)   The origin coordinates of the supercell in which the corresponding atom is\ntranslations : Vector{Vector{Int}}   The itau correspondance for each translational vector. Its size must be equal to the number of q point and   contain all possible translations. This can be obtained from the get_translations subroutine. \n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.shift_position_origin!","page":"Symmetries in Q space","title":"AtomicSymmetries.shift_position_origin!","text":"shift_position_origin!(r_vector::AbstractVector{Complex{T}}, cell::AbstractMatrix{T}, R_lat::AbstractMatrix{T}; buffer) where T\nshift_position_origin!(r_vectors::AbstractMatrix{Complex{T}}, cell::AbstractMatrix{T}, R_lat::AbstractMatrix{T}; buffer) where T\n\nShifts a set of position vectors (r_vector or r_vectors) such that the average position (center of mass) of the reference lattice (R_lat) is moved to the origin. The function operates in-place. This can be employed after performing a Fourier Transform of absolute positions, to correct for non centered R_lat.\n\nThis is typically used to remove the lattice translation from displacement vectors before calculating quantities that are invariant to rigid body translations.\n\nThe average position vector of the reference lattice mathbfr_textavg is calculated in Cartesian coordinates, and then subtracted from the input vectors mathbfr.\n\nmathbfr_textavg = frac1N_textatoms sum_k=1^N_textatoms mathbfr_textlat k\n\nThe position vectors are then shifted:\n\nmathbfr = mathbfr - mathbfr_textavg\n\nArguments\n\nr_vector/r_vectors : The position vector(s) (of type Complex{T}) to be shifted in-place. \ncell : The N_dims times N_dims matrix defining the unit cell (lattice vectors). \nR_lat : The reference lattice positions (fractional/lattice coordinates, N_dims times N_atoms) whose average position determines the shift. \nbuffer : An optional buffer for temporary memory allocation (Bumer.jl)\n\nDetails on r_vectors Matrix Method\n\nThe matrix method assumes that the input r_vectors has the dimensions (N_textconfigs N_textdims times N_textatomsv), where N_textconfigs is the number of configurations, and N_textatomsv is the number of atoms in the vectors being shifted.\n\nThe shift is applied simultaneously to all configurations using broadcasting (@views ... .-=).\n\nExample\n\nAn example of usage after the fourier transform\n\n# Define positions_r as a n_configs, 3n_atoms_sc vector\n# Perform the fourier transform in q space\n# Here, we assume that R_lat and q_points are expressed in crystal coordinates.\n# Otherwise, just pass the identity to the cell below.\nvector_r2q!(positions_q, positions_r, q_points, itau, R_lat)\n\n# Remove the translations\nshift_position_origin!(positions_q, cell, R_lat)\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.SymmetriesQSpace","page":"Symmetries in Q space","title":"AtomicSymmetries.SymmetriesQSpace","text":"SymmetriesQSpace(symmetries :: Symmetries{T}, q_points :: AbstractMatrix{T}) :: SymmetriesQSpace{T} where T\n\nstruct SymmetriesQSpace{T} <: GenericSymmetries where T\n    symmetries :: Symmetries{T}\n    irt_q :: Vector{Vector{Int}}\n    minus_q_index :: Vector{Int}\nend\n\nThis structure contains the information to perform the symmetrization of a dynamical matrix directly in q space.\n\nNote that the q_points needs to be in crystal coordinates,\n\nand the symmetries must be of the primitive cell.\n\nParameters\n\nsymmetries : The symmetries of the primitive cell (Symmetries{T})\nq_points : The q points where the symmetries must be applied (in crystal coordinates)\nirt_q : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from get_irt_q!   Q points linked in this way are related by the symmetry operation in reciprocal space, and belong to the same star of q.\nminus_q_index : A vector containing for each q the corresponding vec q = -vec q + vec G, where vec G is a generic reciprocal lattice vector.\n\n\n\n\n\n","category":"type"},{"location":"fourier_symmetries/#AtomicSymmetries.apply_symmetry_vectorq!","page":"Symmetries in Q space","title":"AtomicSymmetries.apply_symmetry_vectorq!","text":"apply_symmetry_vectorq!(target_vector :: AbstractMatrix{Complex{T}}, original_vector :: AbstractMatrix{Complex{T}}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, irt_q:: AbstractVector{Int})\n\nApply the symmetry on the original vector in q space\n\nParameters\n\ntarget_vector : The result (modified inplace) (3n x nq)\noriginal_vector : The original vector (3n x nq)\nsymmetry_operation : The 3x3 symmetry \nirt : The atom-atom association by symmetry\nirt_q : The q-q association by symmetry\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.apply_symmetry_matrixq!","page":"Symmetries in Q space","title":"AtomicSymmetries.apply_symmetry_matrixq!","text":"apply_symmetry_matrixq!(target_matrix :: AbstractArray{Complex{T}, 3},\n    original_matrix :: AbstractArray{Complex{T}, 3},\n    sym :: AbstractMatrix{U},\n    irt :: AbstractVector{Int},\n    irt_q :: AbstractVector{Int},\n    unit_cell_translations :: AbstractMatrix{T},\n    ; buffer = default_buffer()) where {T, U}\n\nApply the symmetry on the matrix in q space This subroutine assumes the convention that the phase factor is for each supercell, not atoms. In other words, all the atoms coordinates are computed from the same origin of the supercell they are associated with.\n\nParameters\n\ntarget_vector : The result (modified inplace) (3n x nq)\noriginal_vector : The original vector (3n x nq)\nsymmetry_operation : The 3x3 symmetry \nirt : The atom-atom association by symmetry\nirt_q : The q-q association by symmetry\nunit_cell_translations : The translation vectors to move the transformed atom in the primitive cell\nbuffer : The Bumper.jl buffer for caching memory allocations [Optional]\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.get_irt_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_irt_q!","text":"get_irt_q!(irt_q :: AbstractVector{Int}, q_points :: AbstractVector{T}, sym_mat :: AbstractMatrix)\n\nGet the correspondance q = S_textrecip q on the provided q grid. Always assume everything is in crystal coordinates.\n\nNote that in reciprocal space (crystal coordinates) the symmetry operation is the inverse transpose.\n\nS_textrecip = (S_textdirect)^-T\n\nThe provided sym_mat is assumed to be in direct space.\n\nThis is needed for the correct application of the symmetries\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.get_minus_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_minus_q!","text":"get_minus_q!(minus_q_index :: AbstractVector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer()) where T\nget_minus_q!(minus_q_index :: AbstractVector{Int}, q_points :: AbstractMatrix{T}, reciprocal_lattice :: AbstractMatrix{T}; buffer = default_buffer()) where T\n\nIdentify for each q point what is the corresponding -q:\n\nvec q longrightarrow -vec q + vec G\n\nwhere vec G is a reciprocal vector. Since this is done in crystal coordinatesvec G are all possible integers.\n\nThe reciprocal vectors is only needed if the q points are in cartesian coordinates.\n\nParameters\n\nminus_q_index : The result vector (modified inplace)\nq_points : The q points (in crystal coordinates if no reciprocal_lattice is provided, cartesian otherwise)\ncell : The primitive cell (column-based). Only if q_points are in cartesian coordinates. [Optional]\nreciprocal_lattice : The reciprocal lattice vectors (column-based). Only if q_points are in cartesian coordinates. [Optional]\nbuffer : The Bumper.jl buffer for caching memory allocations [Optional, keyword only]\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.check_symmetries","page":"Symmetries in Q space","title":"AtomicSymmetries.check_symmetries","text":"check_symmetries(q_symmetries :: SymmetriesQSpace{T}, n_atoms :: Int) :: Bool\n\nCheck if the q_symmetries has been correctly initialized in the primitive cell.\n\nEssentially, this subroutine checks the atomic correspondance by symmetry and spots if there are atoms outside the primitive cell (whose index is above n_atoms).\n\nParameters\n\nq_symmetries : The symmetries in q space\nn_atoms : The number of atoms in the primitive cell\n\nReturns\n\ntrue if no contraddiction have been detected, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_vector_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_vector_q!","text":"symmetrize_vector_q!(target_gamma :: AbstractVector{T}, original_q :: AbstractArray{Complex{T}, 2}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T\n\nImpose the symmetrization of a vector in q space. Since the symmetrization also imposes translational symmetries, the result is always a vector only at gamma.\n\nThe symmetrized vector is supposed to be a displacement (so no translations are applied)\n\nNOTE: The provided vector must be in crystal coordinates To symmetrize a vector incartesian coordinates, see the routine symmetrize_vector_cartesian_q!.\n\nParameters\n\ntarget_gamma : The n_at * n_dims output symmetrized vector at Gamma\noriginal_q : The original vector in q-space of size nat*n_dims, nq\nsymmetries : The symmetry group\nirt_q : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from get_irt_q!\ngamma_index : Specify which q vector is Gamma. If not specified, it is assumed to be the first one\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_matrix_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_matrix_q!","text":"symmetrize_matrix_q!(target_q :: AbstractArray{Complex{T}, 3}, original_q :: AbstractArray{Complex{T}, 3}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T\nsymmetrize_matrix_q!(matrix_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T\nsymmetrize_matrix_q!(target_q :: AbstractArray{T, 3}, original_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T\n\nImpose the symmetrization of a dynamical matrix in q space. The matrix must be in crystal coordinates.\n\nParameters\n\ntarget_q : The symmetrized matrix of size n_modes, n_modes, nq (modified in-place).\noriginal_q : The original matrix in q-space of size n_modes, n_modes, nq. It could be the same as target_q\nsymmetries : The symmetry group\nirt_q : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from get_irt_q!\nunit_cell_translations :: Vector{Matrix{T}} : The translations of the unit cell to bring back the atoms in the primitive cell after the symmetry operation. Each vector elements corresponds to one symmetry operation, then the matrix is a ndims x natoms translation. This is usually the same as the content of symmetries.unit_cell_translations.\nminus_q_index : A vector containing for each q the corresponding vec q = -vec q + vec G, where vec G is a generic reciprocal lattice vector.\nq_points : The vector containing the actual q points\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_vector_cartesian_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_vector_cartesian_q!","text":"symmetrize_vector_cartesian_q!(vector_q_cart:: AbstractArray{Complex{T}, 2}, cell :: Matrix{T}, symmetries :: SymmetriesQSpace; buffer = default_buffer()) where {T}\n\nPerform the symmetrization of a vector (overwriting it) in cartesian coordinates. This is the go-to subroutine for performing symmetrization of vectors in q space.\n\nParameters\n\nvector_q_cart : in-place symmetrize vector (q-space, cartesian coordinates)\ncell : 3x3 matrix of the primitive cell (column-based)\nsymmetries : Symmetries in Q space\nbuffer : Optional, Bumper stack buffer (caching)\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_matrix_cartesian_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_matrix_cartesian_q!","text":"symmetrize_matrix_cartesian_q!(matrix_q :: AbstractArray{Complex{T}, 3}, cell :: Matrix{T}, q_symmetries :: SymmetriesQSpace; buffer=default_buffer()) where T\n\nEnforce the symmetries on the provided matrix (q-space), modifying it in-place. The provided matrix must be in Cartesian Coordinates.\n\nParameters\n\nmatrix_q : The matrix to be symmetrized. Size (nmodes, nmodes, nq)\ncell : The 3x3 primitive cell (column ordering)\nq_symmetries : The symmetry group (q-space)\nbuffer : Optional, stack for Bumper to cache allocations.\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.impose_hermitianity_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.impose_hermitianity_q!","text":"impose_hermitianity_q!(matrix_q :: AbstractArray{Complex{T}, 3}, minus_q_index; buffer=default_buffer()) where T\n\nImpose the hermitianity and time-reversal symmetry on the dynamical matrix in q space.\n\nParameters\n\nmatrix_q : The dynamical matrix in q space (modified inplace)\nminus_q_index : A vector containing for each q the corresponding vec q = -vec q + vec G, where vec G is a generic reciprocal lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.get_supercell!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_supercell!","text":"get_supercell(q_points::AbstractMatrix{T}, cell :: AbstractMatrix{T}) :: Vector{Int}\nget_supercell(q_points::AbstractMatrix{T}) :: Vector{Int}\nget_supercell!(supercell::AbstractVector{I}, q_points::AbstractMatrix{T}, cell :: AbstractMatrix{T}) where {T, I<:Integer}\nget_supercell!(supercell::AbstractVector{I}, q_points::AbstractMatrix{T}) where {T, I<:Integer}\n\nCalculates the minimum supercell dimensions required to fold a set of commensurate wave vectors (q_points) back to the Gamma point (Γ) of the Brillouin zone.\n\nThe resulting supercell dimension $S_i$ for each spatial direction is determined by the reciprocal of the smallest non-zero q-point component in that direction. For commensurate grids, this is mathematically equivalent to:\n\nS_i = textround left( frac1min(q_i) right)\n\nThis function is primarily used when performing calculations in a real-space supercell that is commensurate with the input k-point (or q-point) grid.\n\nArguments\n\nq_points: A 2D matrix where each column represents a q-point vector, and each row corresponds to a dimension (x, y, z).\nsupercell: An pre-allocated integer vector to store the result (used by the get_supercell! in-place version).\ncell : The primitive cell. If not provided, the code assumes that q_points are    in fractional coordinates.\n\nImportant Note on Coordinates\n\nThe q_points must be provided in crystal coordinates (fractional coordinates) if cell is not provided. \n\nExample\n\n# 3 dimensions, 2 q-points\nq_points = [0.5 0.0;\n            0.0 0.5;\n            0.0 0.25]\n\n# The supercell dimensions required are based on (1/0.5, 1/0.5, 1/0.25).\nsupercell = get_supercell(q_points)\n# Result: [2, 2, 4]\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.get_R_lat!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_R_lat!","text":"get_R_lat!(R_lat :: Matrix{T}, primitive_coords :: Matrix{T}, supercell_coords :: Matrix{T})\n\nGet the R_lat parameter to perform the fourier transform.\n\nParameters\n\nR_lat the result lattice vectors, modified inplace\nprimitive_coords : The coordinates in the primitive cell\nsupercell_coords : The coordinates in the supercell\nitau : The correspondence for each atom in the supercell with the respective atom in the primitive cell\n\n\n\n\n\n","category":"function"},{"location":"acoustic_sum_rule/#Acoustic-sum-rule","page":"Acoustic Sum Rule","title":"Acoustic sum rule","text":"One fundamental aspect of symmetries of phonons is the so called acoustic sum rule. This properties stems from the invariance of physical properties to global translations, and it is reflected to the fact that acoustic phonons, at the center of the Brilluin zone, have a vaninshing energy.\n\nTherefore, the force constant matrix in real space, has always a kernel of dimension equal to the number of acoustic phonons: i.e. the number of operations under which the system is completely invariant.\n\nThe application of the acoustic sum rule depends on the dimensionality of the system, as well as the number of dimension. AtomicSymmetries.jl implements acoustic sum rules via defining a set of rules to compute it.\n\nThe standard acoustic sum rule is imposed by defining a structure ASRConstraint! which contains the dimension of the system. Then, the structure can act as a method to vectors and force constant matrices imposing the ASR condition on them.\n\nIt is possible to automatically identify translational modes with translation_mask! subroutine, which returns false to modes that are purely translational. This is very important to selectively optimize only a subset of modes.","category":"section"},{"location":"acoustic_sum_rule/#AtomicSymmetries.ASRConstraint!","page":"Acoustic Sum Rule","title":"AtomicSymmetries.ASRConstraint!","text":"ASRConstraint!\n\nApply the ASR constraint to a rank-rank tensor of dimension dimension. The application works as \n\nmy_asr! = ASRconstraint!(dimension, 2)\nmy_tensor = rand(nat * dimension, nat * dimension)\nmy_asr!(my_tensor)\n\nThis will apply the ASR constraint to the tensor my_tensor in place.\n\n\n\n\n\n","category":"type"},{"location":"acoustic_sum_rule/#AtomicSymmetries.translation_mask!","page":"Acoustic Sum Rule","title":"AtomicSymmetries.translation_mask!","text":"translation_mask!(mask::Vector{Bool}, pols::Matrix{T}, masses::Vector{T}, n_dims :: Int; multiply :: Bool =true; buffer=default_buffer()) where T\n\nIdentifies translational modes by checking if the crystal's center of mass moves.\n\nThe function updates the mask in-place, setting mask[i] = true for any mode i that does move the center of mass.\n\nArguments\n\nmask::Vector{Bool}: The boolean mask to be updated in-place. mask[i] will be set to true for translational modes.\npols::Matrix{T}: The matrix of mass-weighted polarization eigenvectors, with modes as columns. Must have size (Ndims * Natoms, Nmodes).\nmasses::Vector{T}: A vector of the atomic masses for each atom, with size (Natoms).\nn_dims :: Int : The number of spatial dimensions (e.g., 3 for 3D systems).\nmultiply: (Optional) If true (default), the function computes dispv using the mass-weighted polarization vectors. If false, it computes dispv using the unweighted polarization vectors.\nbuffer: (Optional) A Bumper.jl buffer for allocating the temporary dispv vector to avoid allocations.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.jl-Documentation","page":"Home","title":"AtomicSymmetries.jl Documentation","text":"A package to enforce symmetry constraints on atomic positions in a crystal structure. It also works on dynamical matrices and force constants.\n\nThe package also exploits a memory efficient representation of the symmetry independent components of a tensor. It can be used in pairs with Spglib.jl and the python version of spglib via PyCall for symmetry recognition.","category":"section"},{"location":"#The-symmetry-group","page":"Home","title":"The symmetry group","text":"The key object in this package is the Symmetries type, which represents a symmetry group. The Symmetries is a container for the symmetry operations under which the specific crystal is invariant.\n\nTo build the symmetry group, one can create the following constructor\n\nsymmetry_group = get_identity_symmetry_group(Float64)\n\nThis will create a symmetry group with the identity operation only. The symmetry group can be extended by adding new symmetry operations with the function add_symmetry!.\n\nadd_symmetry!(symmetry_group, symmetry_operation; irt = nothing)\n\nThe symmetry_operation is a 3x3 matrix representing the rotation part of the symmetry operation. The optional argument irt is a vector representing how the symmetry operation exchanges the atoms. In particular the simmetry maps atom i to atom irti. If it is not provided,  the symmetry operation is assumed not to exchange the atoms.\n\nOnce the fundamental symmetry operations have been added, the symmetry group can closed by completing the irreducible representation. This is done by the function complete_symmetry_group.\n\ncomplete_symmetry_group!(symmetry_group)\n\nOnce completed, the symmetry group can be exploited to enforce symmetry constraints on  displacement vectors and 2-rank tensors. In particular, the following subroutines work in crystal coordinates. See below for how to perform the symmetrization in cartesian coordinates.\n\nsymmetry_group.symmetrize_centroid!(vector)\nsymmetry_group.symmetrize_fc!(matrix)","category":"section"},{"location":"#Build-your-own-symmetry-group-(API)","page":"Home","title":"Build your own symmetry group (API)","text":"To build a custom symmetry group, you can exploit the following subroutines","category":"section"},{"location":"#Structure-and-Dynamical-Matrix-symmetrization","page":"Home","title":"Structure and Dynamical Matrix symmetrization","text":"Sometimes it is useful to symmetrize the atomic positions of a crystal structure. To follow the correct Wyckoff positions.  This is achieved with the function symmetrize_positions!.\n\nsymmetrize_positions!(cartesian_coords, cell, symmetry_group)\n\nThis function takes the atomic positions in cartesian coordinates, the cell matrix and the symmetry group. The cell must be column-wise, i.e., each column is a primitive vector of the cell.\n\nIt is also possible just to apply the translational symmetries to either a vector or a force constants matrix. This is achieved calling the subroutine\n\napply_translations!(vector, translations)\napply_translations!(matrix, translations)\n\nwhere the translations is a vector of vector of Ints, each element represent a translations which maps each respective atomic index in the corresponding one. The translations object can be obtained from a symmetry group using the subroutine get_translations.\n\nFor imposing symmetries on a vector or a 2-rank array (like the force constant matrix) directly in cartesian space, you can use\n\nsymmetrize_vector!(vector, unit_cell, symmetry_group)\nsymmetrize_fc!(matrix, unit_cell, symmetry_group)\n\nHere the APIs for these calls","category":"section"},{"location":"#The-symmetry-generators","page":"Home","title":"The symmetry generators","text":"From the symmetry group, we can obtain a vectorial subspace that is invariant under the symmetry operations. A basis of this subspace is given by the symmetry generators. For vectorial quantities, the generators can be obtained as\n\ngenerators = get_vector_generators(symmetry_group)\n\nFor 2-rank tensors, the generators can be obtained as\n\ngenerators = get_matrix_generators(symmetry_group)\n\nThe generators are vectors of indexes that can be used to build the symmetry independent components of a tensor. This allows to store each generator as a 64-bit integer, which is more memory efficient than storing the full tensor. The full vector/2-rank tensor can be retriven with the function get_vector_generator/get_matrix_generator.\n\n# Retrive the first element from the generators\ni = 1\nvector = zeros(3)\nget_vector_generator!(vector, generators[i], symmetry_group)\n\nAnd analogously for 2-rank tensors.\n\nThe generators can be used to project any vector or 2-rank tensor in the symmetry invariant subspace.\n\ncoefficients = zeros(length(generators))\nmy_vector = ...\nget_coefficients_from_vector!(coefficients, my_vector, generators, symmetry_group)\n\nThe previous function projects the vector my_vector in the symmetry invariant subspace and stores the coefficients in the vector coefficient. The coefficients can be used to reconstruct the original vector (symmetrized) as\n\nfinal_vector = similar(my_vector)\nget_centroids_from_generators!(final_vector, generators, coefficients, symmetry_group)\n\nThe same works for 2-rank tensors.\n\n# Get the coefficients of the matrix projected in the symmetric subspace\ncoefficients = zeros(length(generators))\nmy_matrix = ...\nget_coefficients_from_fc!(coefficients, my_matrix, generators, symmetry_group)\n\n# And reconstruct bach the matrix from the coefficients\nfinal_matrix = similar(my_matrix)\nget_fc_from_generators!(final_matrix, generators, coefficients, symmetry_group)","category":"section"},{"location":"#Generators-(API)","page":"Home","title":"Generators (API)","text":"","category":"section"},{"location":"#Spglib-integration","page":"Home","title":"Spglib integration","text":"The symmetry group can be directly constructed exploiting Spglib to recognize the symmetry operations of a crystal structure.\n\nget_symmetry_group_from_spglib(positions::AbstractMatrix{<: Real}, cell::AbstractMatrix{<:Real}, types::Vector{<:Int};  symprec::Float64 = 1e-6, type::Type = Float64, spglib_py_module = nothing) :: Symmetries\n\nHere the arguments are the atomic positions (in crystal coordinates), the cell matrix and the atomic types. Optionally, the symprec parameter can be used to set the tolerance for the symmetry recognition (passed to Spglib).\n\nSince the Spglib.jl implementation is much less mature than the python version,  if needed, it is possible to pass the module of the python version of spglib to the function to replace the Spglib.jl implementation with the Python API from the official spglib package. This requires PyCall.jl to be installed.","category":"section"},{"location":"#Spglib-API","page":"Home","title":"Spglib API","text":"","category":"section"},{"location":"#How-to-get-crystal-coordinates","page":"Home","title":"How to get crystal coordinates","text":"The code also allows for a quick conversion between cartesian and crystal coordinates. Assuming cartesian_positions is a 3xNat matrix of atomic positions in cartesian coordinates and cell is the 3x3 cell matrix (each column is a primitive vector), the crystal coordinates can be obtained as\n\ncrystal_positions = similar(cartesian_positions)\nget_crystal_coords!(crystal_positions, cartesian_positions, cell)\n\nOptionally, a Bumper.jl buffer can be passed to the function to avoid memory allocations, otherwise, the default_buffer() is retrived.\n\nThe cartesian coordinates can be obtained as\n\nget_cartesian_coords!(cartesian_positions, crystal_positions, cell)\n\nThis function does not require any memory allocation.\n\nNotably, a much faster, nonallocating implementation can be used if the reciprocal vectors are available, which can perform transformation of both real space and q space. Reciprocal vectors can be computed using the get_reciprocal_lattice! subroutine, while the crystal-cartesian conversion is obtained through cryst_cart_conv!.","category":"section"},{"location":"#Filter-symmetries","page":"Home","title":"Filter symmetries","text":"It is possible to filter symmetries incompatible with a given external perturbation. At this stage, only linear perturbations are supported. For example, to filter the symmetries that are not compatible with a perturbation along the x direction, one can use\n\nfilter_invariant_symmetries!(symmetry_group, [1.0, 0.0, 0.0])\n\nAll symmetry operations not leaving the perturbation vector invariant are removed from the symmetry group. Since version 0.2, it is possible to parse a vector of size ndimension * natoms,  with a different displacement vector acting on each atom.","category":"section"},{"location":"#Symmetry-sparsification","page":"Home","title":"Symmetry sparsification","text":"A new feature available since version 0.7 is the possibility to get the symmetry matrices as CSC sparse matrices. To sparsify a symmetry group, you just need to use the sparse method from the SparseArrays library (novel dependency of 0.7)\n\nUsing SparseArrays\nsparse_symmetry_group = sparse(symmetry_group)\n\n# Apply the symmetry 5th operation on a vector v (previosly defined)\nv_new = apply_sparse_symmetry(sparse_symmetry_group.symmetries[5], v)\n\nNotably, this is differentiable via Zygote and Enzyme, so it allows to implement symmetrization in a differentiable way. v could also be a series of vector as a Matrix where each vector is stored as a column of v.","category":"section"},{"location":"#AtomicSymmetries.Symmetries","page":"Home","title":"AtomicSymmetries.Symmetries","text":"mutable struct Symmetries{T}\n\nThe structure containing the symmetries of the system.\n\nOnce the symmetries have been initialized,  the symmetrizefc! and symmetrizecentroid! functions can be used to symmetrize the force constant matrix and the centroid.\n\nThe exchange_symmetry is a vector of length n_particles,  where each element identify the id of the particle. If two ids are equal, the particles are indistinguishable.\n\nirt[i][j] is the index of the atom that is equivalent to the j-th atom before the symmetry is applied. The expression is\n\nv_textirti = S v_i\n\nThe name irt stands for \"index of the representative of the transformation\". and it is in line with the notation used in the Quantum Espresso and the CellConstructor codes.\n\nThe unit_cell_translations attribute contains the list of translational vectors for each symmetry that reports atoms after the symmetry application into their equivalent primitive cell position. This is equal to\n\nSvec a =  vec s(a) + vec t_s a\n\nwhere s(a) is the equivalent atom to a in the primitive cell mapped by the S symmetry operation. The translation vector vec t_s a is stored in unit_cell_translations. Each element correspond to the relative symmetry operation, and it is a matrix of dimension (dimension n_particles). Each column correspond to the translation vector of each atom. ```\n\n\n\n\n\n","category":"type"},{"location":"#AtomicSymmetries.complete_symmetry_group!","page":"Home","title":"AtomicSymmetries.complete_symmetry_group!","text":"complete_symmetry_group!(symmetries :: Symmetries{T})\n\nComplete the symmetry group by adding the inverse symmetry operations and the compositions of the symmetry operations, until the group is closed.\n\nSince symmetry are unitary transformations,  the inverse symmetry operation is the transpose of the symmetry operation.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.add_symmetry!","page":"Home","title":"AtomicSymmetries.add_symmetry!","text":"add_symmetry!(sym :: Symmetries{T}, symm :: Matrix{T}; update :: Bool = true, check_existing :: Bool = false) :: where {T}\n\nAdd a symmetry to the system.\n\nIf update is true, the symmetrizefc! and symmetrizecentroid! functions are updated. If check_existing is true, the symmetry is only added if it is not already in the list of symmetries.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_identity_symmetry_group","page":"Home","title":"AtomicSymmetries.get_identity_symmetry_group","text":"get_identity_symmetry_group(T :: Type) :: Symmetries{T}\n\nThis function returns the symmetry group containing only the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_cylindrical_symmetry_group","page":"Home","title":"AtomicSymmetries.get_cylindrical_symmetry_group","text":"get_cylindrical_symmetry_group(T :: Type, axis :: Int) :: Symmetries{T}\n\nThe cylindrical symmetry group is the group of all rotation around one axis, plus all inversions.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_spherical_symmetry_group","page":"Home","title":"AtomicSymmetries.get_spherical_symmetry_group","text":"get_spherical_symmetry_group(T :: Type, dims :: Int = 3) :: Symmetries{T}\n\nReturn the symmetry group of all rotation and inversion operations in the dimension of the system.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_full_inversion_symmetry_group","page":"Home","title":"AtomicSymmetries.get_full_inversion_symmetry_group","text":"get_full_inversion_symmetry_group(T :: Type, dims :: Int =2) :: Symmetries{T}\n\nReturn the group of inversion symmetries along the x, y, and z axis. This suppose that atoms are not exchanged by the symmetry.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.symmetrize_positions!","page":"Home","title":"AtomicSymmetries.symmetrize_positions!","text":"symmetrize_positions!(positions :: AbstractMatrix{T}, cell :: AbstractMatrix, symmetry_group :: Symmetries; buffer=default_buffer()) where {T}\n\nsymmetrize an atomic coordinates in real space.  This subroutie symmetrizes a system with Cartesian coordinats (positions) using the specified symmetry group (that must include translations).\n\nIf you want to symmetrize a quantity that is invariant under translations (e.g. a force or a displacement), use symmetrize_vector! instead.\n\nThe function operates in place, meaning that the final result overwrites the input positions.\n\nThis function exploits Bumper.jl stack allocation to avoid memory allocation, you can manually specify the stack buffer as an optional keyword argument buffer.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.symmetrize_vector!","page":"Home","title":"AtomicSymmetries.symmetrize_vector!","text":"symmetrize_vector!(vector :: AbstractVector{T}, cell :: AbstractMatrix, symmetry_group :: Symmetries; buffer=default_buffer()) where {T}\n\nSymmetrize the vector vector using the symmetry group symmetry_group. The vector has a length of dim * nat, where nat is the number of atoms in the system. It is assumed to represent a quantity that is invariant under translations (e.g. a force or a displacement). If you want to symmetrize a quantity that is not invariant under translations (e.g. atomic positions), use symmetrize_positions! instead.\n\nThis function assumes that the vector is provided in cartesian coordinates, opposite to symmetry_group.symmetrize_centroid!, which assumes that the vector is in crystal coordinates. Note that to symmetrize cartesian coordinates, also the primitive cell is required (cell).\n\nThe function operates in place, meaning that the final result overwrites the input vector.\n\nThis function exploits Bumper.jl stack allocation to avoid memory allocation. The stack can be manually specified as an optional keyword argument buffer.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.symmetrize_fc!","page":"Home","title":"AtomicSymmetries.symmetrize_fc!","text":"symmetrize_fc!(fc :: AbstractMatrix{T}, cell :: AbstractMatrix, symmetry_group :: Symmetries; buffer=default_buffer()) where {T}\n\nSymmetrize the force constant matrix fc using the symmetry group symmetry_group. This function assumes that the force constant matrix is in cartesian coordinates, opposite to symmetry_group.symmetrize_fc!, which assumes that the force constant matrix is in crystal coordinates. Note that to symmetrize cartesian coordinates, also the primitive cell is required (cell).\n\nThe function operates in place, meaning that the final result overwrites the input force constant matrix fc.\n\nThis function exploits Bumper.jl stack allocation to avoid memory allocation. The stack can be manually specified as an optional keyword argument buffer.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_translations","page":"Home","title":"AtomicSymmetries.get_translations","text":"get_translations(symmetry :: GenericSymmetries) :: Vector{Vector{Int}}\n\nReturn a vector containin, for each element,  the corrispondence of couple of atoms mapped by the respective translational symmetry.\n\nThis function extract the translations from the global symmetry object.\n\nParameters\n\nsymmetries :: Symmetries : The symmmetry object that contains the symmetries of the structure.\n\n\n\n\n\nget_translations(coords :: AbstractMatrix{T}, supercell, R_lat :: Vector{I}) :: Vector{Vector{I}} where {T, I<: Integer}\n\nReturn a vector containin, for each element,  the corrispondence of couple of atoms mapped by the respective translational symmetry.\n\nFor the mapping, see get_irt! documentation.\n\nParameters\n\ncoords : the atomic coordinates in crystalline axes (in the supercell)\nsupercell : The dimension of the supercel (e.g. a 3x3x3 supercell should be a tuple (3,3,3) )\nR_lat : The translations operated, i.e. the vectors of each translations (of the primitive cell). Note that this are integers.\n\nResults\n\ntranslations : A vector containing the mapping between atoms operated by the respective translations in R_lat.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.apply_translations!","page":"Home","title":"AtomicSymmetries.apply_translations!","text":"apply_translations!(matrix :: Matrix{T}, translations :: Vector{Vector{Int}};\napply_translations!(matrix :: Vector{T}, translations :: Vector{Vector{Int}};\n\nEnforce the translational symmetries on a supercell matrix or vector. The translational symmetries are encoded by the translations vector. Each element of the translations vectors contains the maps of the atomic indices mapped one into the other by the specific translation.\n\nM_ab = frac1N_tsum_t M_t(a)t(b)\n\nwhere t(a) is the atom in which the translation t maps the a atom.\n\nIn the case of a vector, instead, we have\n\nv_a = frac1N_tsum_t v_t(a)\n\nParameters\n\nmatrix or vector : the in-place modified tensor to be symmetrized\ntranslations : the array of the translations\nbuffer : The stack buffer for caching (Bumper.jl) [optional]\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_vector_generators","page":"Home","title":"AtomicSymmetries.get_vector_generators","text":"get_vector_generators(symmetry_group::Symmetries{U},\n                      unit_cell :: AbstractMatrix{T};\n                   func_apply_constraints! = nothing)\n                    :: Vector{Int} where {T, U}\n\nGet the generators of the symmetry group for the vectors.\n\nArguments\n\nsymmetry_group::Symmetries{U}: The symmetry group to be considered in the generator creation process.\nunit_cell :: AbstractMatrix{T}: The unit cell of the system.\nfunc_apply_constraints!::Function (optional): A function to apply constraints to the parameters. Defaults to nothing.\n\nReturns\n\nVector{Int}: A vector of indices representing the set of independent generators.\n\nDescription\n\nThis function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of vectors that are invariant under the symmetry group.\n\nNote that the generators are computed in cartesian coordinates(FC)\n\nThe independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.\n\nThe function ultimately returns a vector of indices representing the independent generators found during the process.\n\nExamples\n\nsymmetry_group = # Symmetries object\ngenerators = get_vector_generators(symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_matrix_generators","page":"Home","title":"AtomicSymmetries.get_matrix_generators","text":"get_matrix_generators(symmetry_group::Symmetries{U},\n                      unit_cell :: AbstractMatrix{T};\n                   func_apply_constraints! = nothing)\n                    :: Vector{Int} where {T, U}\n\nGet the generators of the symmetry group for the matrices.\n\nArguments\n\nsymmetry_group::Symmetries{U}: The symmetry group to be considered in the generator creation process.\nunit_cell :: AbstractMatrix{T}: The unit cell of the system.\nfunc_apply_constraints!::Function (optional): A function to apply constraints to the parameters. Defaults to nothing.\n\nReturns\n\nVector{Int}: A vector of indices representing the set of independent generators.\n\nDescription\n\nThis function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of matrices that are invariant under the symmetry group.\n\nNote that the generators are computed in cartesian coordinates(FC)\n\nThe independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.\n\nThe function ultimately returns a vector of indices representing the independent generators found during the process.\n\nExamples\n\nsymmetry_group = # Symmetries object\ngenerators = get_matrix_generators(symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_vector_generator!","page":"Home","title":"AtomicSymmetries.get_vector_generator!","text":"get_vector_generator!(generator::Vector{T}, generator_index::Int, n_modes::Int, n_layers::Int, symmetry_group::Symmetries{U};\n               use_sqrt_representation=true, optimize_struct=true, optimize_nltransf=true, \n               func_apply_constraints!=nothing, baseline_generator=nothing, normalize=true) where {T, U}\n\nModify generator in-place to represent a specific generator of a transformation, subject to given constraints and symmetries.\n\nThe generatorindex parameter ranges from 1 to Nmax, where N_max represents the maximum dimension of the parameters, and it should be noted that some indices within this range may yield identical generators due to the underlying symmetries or constraints in the system.\n\nArguments\n\ngenerator::Vector{T}: The generator vector to be modified.\ngenerator_index::Int: Index specifying which generator to construct.\nn_modes::Int: The number of modes in the system.\nn_layers::Int: The number of layers in the neural network model.\nsymmetry_group::Symmetries{U}: The symmetry group to be imposed on the generator.\nuse_sqrt_representation::Bool (optional): Flag to use the square root representation. Defaults to true.\noptimize_struct::Bool (optional): Flag to optimize the structure. Defaults to true.\noptimize_nltransf::Bool (optional): Flag to optimize nonlinear transformations. Defaults to true.\nfunc_apply_constraints!::Function (optional): A function to manually apply constraints to the parameters. Defaults to nothing.\nbaseline_generator::Vector{T} (optional): A baseline generator for comparison. Defaults to nothing.\nnormalize::Bool (optional): Flag to normalize the generator. Defaults to true.\n\nDescription\n\nThis function constructs a generator vector that represents a transformation in a specified manner. It initializes the generator vector with zeros and sets the generator_index element to 1. The function builds a scha (Structured Component Histogram Analysis) and an nltransf (Non-Linear Transform) based on the specified parameters. The scha and nltransf are then used to set the parameters of the generator.\n\nIf func_apply_constraints! is provided, it is used to apply constraints to the scha and nltransf. If baseline_generator is provided, the function adjusts the generator relative to this baseline. Symmetry constraints from symmetry_group are imposed on the nltransf and scha.\n\nFinally, the function updates the generator with the parameters obtained from scha and nltransf, optionally subtracting the baseline generator and normalizing the result.\n\nExamples\n\ngenerator = zeros(Float64, 10)\nget_vector_generator!(generator, 2, 5, 3, my_symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_coefficients_from_vector!","page":"Home","title":"AtomicSymmetries.get_coefficients_from_vector!","text":"get_coefficients_from_vector!(coefficients :: Vector{T}, vector:: Vector{T}, generators :: Vector{Int},\n    n_modes::Int, n_layers :: Int;\n    use_sqrt_representation=true,\n    optimize_struct=true,\n    optimize_nltransf=true) where {T}\n\nGet the coefficients obtained as the scalar product between a vector and the generators:\n\nalpha_i = vec g_i cdot vec v\n\nwhere \\alpha_i is the i-th computed coefficient, \\vec g_i is the i-th generator, and \\vec v is the provided vector.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_centroids_from_generators!","page":"Home","title":"AtomicSymmetries.get_centroids_from_generators!","text":"get_centroids_from_generators!(centroids:: AbstractVector{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetries :: Symmetries, n_modes :: Int; kwargs...)\n\nReturn the parameters from the generators and the coefficients. The centroids vec v are obtained in-place as \n\nvec v = sum_i alpha_i vec g_i\n\nwhere \\alpha_i are the generator coefficients, while \\vec g_i is the i-th vector generator.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_coefficients_from_fc!","page":"Home","title":"AtomicSymmetries.get_coefficients_from_fc!","text":"get_coefficients_from_fc!(coefficients :: Vector{T}, matrix:: Matrix{T}, generators :: Vector{Int},\n    n_modes::Int, n_layers :: Int;\n    use_sqrt_representation=true,\n    optimize_struct=true,\n    optimize_nltransf=true) where {T}\n\nGet the coefficients obtained as the scalar product between a given matrix and the generators:\n\nalpha_i = textTr G_i M\n\nwhere \\alpha_i is the i-th computed coefficient, G_i is the i-th matrix generator, and M is the provided Matrix.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_fc_from_generators!","page":"Home","title":"AtomicSymmetries.get_fc_from_generators!","text":"get_fc_from_generators!(fc:: AbstractMarix{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetryes :: Symmetries, cell :: AbstractMatrix; kwargs...)\n\nReturn the Matrix from the coefficient representation. The fc matrix M is obtained in-place as \n\nM = sum_i alpha_i G_i\n\nwhere \\alpha_i are the generator coefficients, while G_i is the i-th matrix generator.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_symmetry_group_from_spglib","page":"Home","title":"AtomicSymmetries.get_symmetry_group_from_spglib","text":"get_symmetry_group_from_spglib(positions :: AbstractMatrix, cell :: AbstractMatrix, types :: Array{Int}; \n    symprec :: Float64 = 1e-6,\n    type :: Type = Float64, spglib_py_module = nothing) :: Symmetries\n\nBuild a symmetry group from the spglib library. Optionally, this function can be called with a spglib python module. In this way, the python module will be used to get the symmetry operations (since the julia spglib module is buggy).\n\nArguments\n\npositions::AbstractMatrix: The atomic positions in the cell (crystallographic coordinates), with shape (3, N).\ncell::AbstractMatrix: The cell matrix with shape (3, 3).\ntypes::Array{Int}: The atomic types.\n\nOptional arguments:\n\nsymprec::Float64: The symmetry precision.\ntype::Type: The numerical precision type for the symmetry operations.\nspglib_py_module: The spglib python module. If not provided, the default julia spglib module is used.\n\nAlternatively, you can pass an ASE Atoms object.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.cryst_cart_conv!","page":"Home","title":"AtomicSymmetries.cryst_cart_conv!","text":"cryst_cart_conv!(target, source, primitive_cell, reciprocal_vectors, cryst_to_cart; q_space=false)\n\nIn-place conversion of coordinates between crystallographic and Cartesian systems, supporting both real and reciprocal (q) space.\n\nThe function performs one of four transformations based on the boolean flags cryst_to_cart and q_space. It computes target = α * T * source, where T is the transformation matrix and α is a scaling factor.\n\nArguments\n\ntarget::AbstractArray{T}: The destination array, which is modified in-place.\nsource::AbstractArray{T}: The source array containing the coordinates to be transformed.\nprimitive_cell::AbstractMatrix{U}: The matrix whose columns represent the primitive lattice vectors (e.g., A = a₁ a₂ a₃).\nreciprocal_vectors::AbstractMatrix{U}: The matrix whose columns represent the reciprocal lattice vectors (e.g., B = b₁ b₂ b₃).\ncryst_to_cart::Bool: The direction of the transformation.\ntrue: Crystallographic coordinates (unitless) to Cartesian (units of length or 1/length).\nfalse: Cartesian to Crystallographic.\n\nKeyword Arguments\n\nq_space::Bool = false: Toggles between real space and reciprocal (q) space.\nfalse: Real-space transformation.\ntrue: Reciprocal-space (q-space) transformation.\n\nOperations Performed\n\nLet A = primitive_cell and B = reciprocal_vectors. The function assumes the standard physics definition where A^T B = 2pi I.\n\nThe function calculates target = α * T * source based on the following cases:\n\ncryst_to_cart=true, q_space=false: (Cryst → Cart, Real Space)\nT = A\nα = 1.0\ntarget = A * source\ncryst_to_cart=true, q_space=true: (Cryst → Cart, Q-Space)\nT = B\nα = 1.0\ntarget = B * source\ncryst_to_cart=false, q_space=false: (Cart → Cryst, Real Space)\nT = B' (Transpose of reciprocal_vectors)\nα = 1.0\ntarget = B' * source\ncryst_to_cart=false, q_space=true: (Cart → Cryst, Q-Space)\nT = A' (Transpose of primitive_cell)\nα = 1 / (2π)\ntarget = (1 / (2π)) * A' * source (This is correct, as B^-1 = frac12pi A^T)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_reciprocal_lattice!","page":"Home","title":"AtomicSymmetries.get_reciprocal_lattice!","text":"get_reciprocal_lattice!(reciprocal_vectors :: Matrix{T}, cell :: Matrix{T})\n\nCompute the reciprocal lattice vectors from the primitive cell.\n\nReciprocal lattice vectors boldsymbolB (columns of the matrix) satisfy the property\n\nboldsymbolB^dagger boldsymbolA = 2pi boldsymbolI\n\nwhere boldsymbolA is the matrix whose columns are the direct lattice vectors, and boldsymbolI is the identity matrix.\n\nParameters\n\nreciprocal_vectors : The boldsymbolB matrix, whose columns are   the reciprocal lattice vectors (modified in-place).\ncell : The matrix whose columns are the primitive direct lattice vectors.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.filter_invariant_symmetries!","page":"Home","title":"AtomicSymmetries.filter_invariant_symmetries!","text":"filter_invariant_symmetries!(symmetry_group :: Symmetries, vector :: AbstractVector, cell :: AbstractMatrix;\n                             buffer=default_buffer())\n\nThis subroutine filters the symmetries in symmetry_group that does  not leave the vector vector invariant under their transformation.\n\nNote that vector is assumed in Cartesian coordinates (not crystalline) since version 0.6.0\n\nFor example, inversion symmetry is not compatible with a vector that is not the null vector, so it will be removed from the symmetry group. While a reflection symmetry is compatible with any vector lying on the reflection plane,  so it will be kept in the symmetry group.\n\nThis is userful if the symmetries are evaluated from a set of atomic positions, But we then need symmetries that also are invariant under an external perturbation along a certain direction.\n\n\n\n\n\nfilter_invariant_symmetries!(symmetry_group :: SymmetriesQSpace, vector :: AbstractVector, cell :: AbstractMatrix;\n                             buffer=default_buffer())\n\nThis subroutine filters the symmetries in symmetry_group that does  not leave the vector vector invariant under their transformation.\n\nIt removes the symmetries violated by the vector. This works for symmetry groups expressed in q space\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.apply_sparse_symmetry","page":"Home","title":"AtomicSymmetries.apply_sparse_symmetry","text":"function apply_sparse_symmetry(sparse_s :: SparseMatrixCSC{T}, v :: AbstractArray{U}) where {T, U}\n\nThis function applies the sparse symmetry matrix to a displacement vector.\n\nThe inplace version should be nonallocating.\n\n\n\n\n\n","category":"function"}]
}

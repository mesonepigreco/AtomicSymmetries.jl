var documenterSearchIndex = {"docs":
[{"location":"fourier_symmetries/#Symmetries-in-Fourier-space","page":"Symmetries in Q space","title":"Symmetries in Fourier space","text":"","category":"section"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"The symmetrization can be performed also in Fourier space. This is implemented now for force-constant dynamical matrices and vectors (displacements, forces, ...).","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"A vector is transformed from real to q-space with the following convention:","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle tilde v_k(vec q) = frac1sqrtN_q sum_R e^-i 2pi vec Rcdot vec q v_k(vec R)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle v_k(vec R) = frac1sqrtN_q sum_R e^i 2pi vec Rcdot vec q tilde v_k(vec q)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"Note the sign of the Fourier and the normalization prefactor. With this convention, we recover the standard rule for the matrices.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle tilde Phi_ab(vec q) = sum_vec R e^2pi i vec qcdot vec RPhi_ab + vec R","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle Phi_ab = frac1N_q sum_vec q tildePhi_ab(vec  q) e^2ipi vec qcdotvec R(a) - vec R(b)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"Note that these transformation of matrices and vector are consistent so that matrices and vector written as outer product can be consistently transformed","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle Phi(vec R) = sum_isum_vec R vec v_i(vec R_1) otimes vec v_i(vec R_1 + vec R)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"displaystyle tilde Phi(vec q) = sum_i vec tilde v_i(vec q) otimes vec tilde v_i(-vec q)","category":"page"},{"location":"fourier_symmetries/#Fourier-transform","page":"Symmetries in Q space","title":"Fourier transform","text":"","category":"section"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"The API to perform the fourier transform occur mainly with vector_r2q!, vector_q2r! which, respectively, trasform a vector from real to q space and vice-versa. Transformation of matrices occur with matrix_r2q!, matrix_q2r!. All these operations are inplace. The matrices are assumed in crystal coordinates, but in this case it should not matter.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"The detailed API calls are","category":"page"},{"location":"fourier_symmetries/#AtomicSymmetries.vector_r2q!","page":"Symmetries in Q space","title":"AtomicSymmetries.vector_r2q!","text":"vector_r2q!(\n    v_q :: AbstractArray{Complex{T}, 3},\n    v_sc :: AbstractMatrix{T},\n    q_tot :: Matrix{T})\nvector_r2q!(v_q :: AbstractArray{Complex{T}, 2},\n    v_sc :: AbstractVector{T},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T}\n) where {T <: AbstractFloat, I <: Integer}\n\nFourier transform a vector from real space and q space.\n\ndisplaystyle v_k(vec q) = frac1sqrtN_q sum_R e^-i 2pi vec Rcdot vec q v_k(vec R)\n\nIt works both on a single vector and on a series of vector.  NOTE: In the latter case, the number of configurations must be in the first column.  This is not standard,  but implemented in this way for performance reasons as it is the most convenient memory rapresentation for vectorizing the average calculation.\n\nParameters\n\nv_q : (nconfigs, 3nat, nq)    The target vector in Fourier space. Optionally, nconfigs could be omitted if transforming only 1 vector\nv_sc : (nconfigs, 3*natsc)   The original vector in real space. Optionally, n_configs could be omitted if transforming only 1 vector\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nR_lat : (3, nat_sc)   The origin coordinates of the supercell in which the atom is\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.vector_q2r!","page":"Symmetries in Q space","title":"AtomicSymmetries.vector_q2r!","text":"vector_q2r!(\n    v_sc :: AbstractMatrix{T},\n    v_q :: AbstractArray{Complex{T}, 3},\n    q_tot :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T}) where {T <: AbstractFloat, I <: Integer}\nfunction vector_q2r!(\n    v_sc :: AbstractVector{T},\n    v_q :: AbstractMatrix{Complex{T}},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T}\n) where {T <: AbstractFloat, I <: Integer}\n\nFourier transform a vector from q space to real space.\n\ndisplaystyle v_k(vec R) = frac1sqrtN_q sum_R e^+i 2pi vec Rcdot vec q v_k(vec q)\n\nIt can be applied both to a single vector and in an ensemble. NOTE: In the latter case, the configurations must be stored as the first index. This choice is made for performance reason in computing averages (exploiting vectorization).\n\nParameters\n\nv_sc : (nconfigs, 3*natsc)   The target vector in real space. Optionally, n_configs can be omitted\nv_q : (nconfigs, nq, 3*nat)    The original vector in Fourier space. Optionally, nconfigs can be omitted\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nR_lat : (3, nat_sc)   The origin coordinates of the supercell in which the atom is\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.matrix_r2q!","page":"Symmetries in Q space","title":"AtomicSymmetries.matrix_r2q!","text":"matrix_r2q!(\n    matrix_q :: Array{Complex{T}, 3},\n    matrix_r :: AbstractMatrix{T},\n    q :: Matrix{T},\n    itau :: Vector{I},\n    R_lat :: Matrix{T})\n\nFourier transform a matrix from real to q space\n\ndisplaystyle M_ab(vec q) = sum_vec R e^2pi i vec qcdot vec RPhi_ab + vec R\n\nWhere Phi_ab is the real space matrix, the b+vec R indicates the corresponding atom in the supercell displaced by vec R. \n\nParameters\n\nmatrix_q : (3nat, 3nat, nq)    The target matrix in Fourier space.\nmatrixr : (3*natsc, 3*nat)   The original matrix in real space (supercell)\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nRlat : (3, natsc)   The origin coordinates of the supercell in which the corresponding atom is\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.matrix_q2r!","page":"Symmetries in Q space","title":"AtomicSymmetries.matrix_q2r!","text":"matrix_q2r!(\n    matrix_r :: AbstractMatrix{T},\n    matrix_q :: Array{Complex{T}, 3},\n    q :: Matrix{T},\n    itau :: Vector{Int},\n    R_lat :: Matrix{T})\n\nFourier transform a matrix from q space into r space\n\ndisplaystyle Phi_ab = frac1N_q sum_vec q M_ab(vec  q) e^2ipi vec qcdotvec R(a) - vec R(b)\n\nWhere Phi_ab is the real space matrix, M_ab(vec q) is the q space matrix.\n\nParameters\n\nmatrixr : (3*natsc, 3*nat)   The target matrix in real space (supercell). If the second dimension is 3nat_sc, we also apply the translations\nmatrix_q : (3nat, 3nat, nq)    The original matrix in Fourier space.\nq_tot : (3, nq)   The list of q vectors\nitau : (nat_sc)   The correspondance for each atom in the supercell with the atom in the primitive cell.\nRlat : (3, natsc)   The origin coordinates of the supercell in which the corresponding atom is\ntranslations : Vector{Vector{Int}}   The itau correspondance for each translational vector. Its size must be equal to the number of q point and   contain all possible translations. This can be obtained from the get_translations subroutine. \n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#Applications-of-symmetries-in-Fourier-space","page":"Symmetries in Q space","title":"Applications of symmetries in Fourier space","text":"","category":"section"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"The application of symmetries in Fourier space must also account how points in q space are mapped by the symmetry operations.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"For this, the important information about how q points are related by symmetries needs to be computed and stored. This identification is performed by the helper function get_irt_q!, which identifies, for a given symmetry operation, the i->j mapping between q points. Q points mapped into themselves by the same set of symmetry operations form the socalled small-group of q, while the set of q points mapped by all the symmetries of a crystal is called the star of the q point. Due to time-inversion symmetry, the dynamical matrix must also satisfy the condition","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"D(q) = D^dagger(-q + G)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"therefore it is necessary also to keep track, for each q point, which one is the corresponding -q + G in the mesh. This mapping is computed by the helper function get_minus_q!. All these information needs to be stored when applying symmetries. Therefore we defined a new Symmetries struct that ihnerits from the GenericSymmetries called SymmetriesQSpace","category":"page"},{"location":"fourier_symmetries/#AtomicSymmetries.SymmetriesQSpace","page":"Symmetries in Q space","title":"AtomicSymmetries.SymmetriesQSpace","text":"SymmetriesQSpace(symmetries :: Symmetries{T}, q_points :: AbstractMatrix{T}) :: SymmetriesQSpace{T} where T\n\nstruct SymmetriesQSpace{T} <: GenericSymmetries where T\n    symmetries :: Symmetries{T}\n    irt_q :: Vector{Vector{Int}}\n    minus_q_index :: Vector{Int}\nend\n\nThis structure contains the information to perform the symmetrization of a dynamical matrix directly in q space. Note that the q_points needs to be in crystal coordinates.\n\n\n\n\n\n","category":"type"},{"location":"fourier_symmetries/#AtomicSymmetries.get_irt_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_irt_q!","text":"get_irt_q!(irt_q :: AbstractVector{Int}, q_points :: AbstractVector{T}, sym_mat :: AbstractMatrix)\n\nGet the correspondance q' = Sq on the provided q grid. Always assume everything is in crystal coordinates\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.get_minus_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.get_minus_q!","text":"get_minus_q!(minus_q_index :: AbstractVector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer()) where T\n\nIdentify for each q point what is the corresponding -q:\n\nvec q longrightarrow -vec q + vec G\n\nwhere vec G is a reciprocal vector. Since this is done in crystal coordinatesvec G are all possible integers.\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#Application-of-symmetries","page":"Symmetries in Q space","title":"Application of symmetries","text":"","category":"section"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"Applying a symmetry means transforming a vector or a matrix (already in q-space) into a new vector (matrix). If the vector (matrix) is invariant under that transformation, then that transformation belong to the symmetry group.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"To apply the symmetry to a matrix we use the apply_symmetry_vectorq!. For the matrix, we use apply_symmetry_matrixq!. Both these function modify in-place the first argument, storing the result of the transformation there. Note that, since symmetries are stored in crystalline components, both the vector and the matrix must be in crystalline components. ","category":"page"},{"location":"fourier_symmetries/#AtomicSymmetries.apply_symmetry_vectorq!","page":"Symmetries in Q space","title":"AtomicSymmetries.apply_symmetry_vectorq!","text":"apply_symmetry_vectorq!(target_vector :: AbstractMatrix{Complex{T}}, original_vector :: AbstractMatrix{Complex{T}}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, q_points :: AbstractMatrix{T})\n\nApply the symmetry on the original vector in q space\n\nParameters\n\ntarget_vector : The result (modified inplace) (3n x nq)\noriginal_vector : The original vector (3n x nq)\nsymmetry_operation : The 3x3 symmetry \nirt : The atom-atom association by symmetry\nirt_q : The q-q association by symmetry\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.apply_symmetry_matrixq!","page":"Symmetries in Q space","title":"AtomicSymmetries.apply_symmetry_matrixq!","text":"apply_symmetry_matrixq!(target_matrix :: AbstractArray{Complex{T}, 3}, original_matrix :: AbstractArray{Complex{T}, 3}, symmetry_operation :: AbstractMatrix{U}, irt :: Vector{Int}, q_points :: AbstractMatrix{T}; buffer = default_buffer())\n\nApply the symmetry on the matrix in q space This subroutine assumes the convention that the phase factor is for each supercell, not atoms. In other words, all the atoms coordinates are computed from the same origin of the supercell they are associated with.\n\nParameters\n\ntarget_vector : The result (modified inplace) (3n x nq)\noriginal_vector : The original vector (3n x nq)\nsymmetry_operation : The 3x3 symmetry \nirt : The atom-atom association by symmetry\nirt_q : The q-q association by symmetry\nbuffer : The Bumper.jl buffer for caching memory allocations [Optional]\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#Enforcing-symmetries","page":"Symmetries in Q space","title":"Enforcing symmetries","text":"","category":"section"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"One of the most useful operation to do is enforce a specific matrix or vector in q-space to satisfy a given symmetry group.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"This can be implemented by applying the complete irreducible representation of the symmetry group. Symmetrization of an ent \\phi is obtained as","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"Phi = frac1Nsum_i=1^N S_i(phi)","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"where S_i is the symmetry operation. The two functions performing the symmetrization are symmetrize_matrix_q! and symmetrize_vector_q!. Also in this case, the dynamical matrix must be provided in crystalline coordinates.","category":"page"},{"location":"fourier_symmetries/","page":"Symmetries in Q space","title":"Symmetries in Q space","text":"Here the complete API","category":"page"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_vector_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_vector_q!","text":"symmetrize_vector_q!(target_gamma :: AbstractVector{T}, original_q :: AbstractArray{Complex{T}, 2}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T\n\nImpose the symmetrization of a vector in q space. Since the symmetrization also imposes translational symmetries, the result is always a vector only at gamma.\n\nThe symmetrized vector is supposed to be a displacement (so no translations are applied)\n\nParameters\n\ntarget_gamma : The n_at * n_dims output symmetrized vector at Gamma\noriginal_q : The original vector in q-space of size nat*n_dims, nq\nsymmetries : The symmetry group\nirt_q : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from get_irt_q!\ngamma_index : Specify which q vector is Gamma. If not specified, it is assumed to be the first one\n\n\n\n\n\n","category":"function"},{"location":"fourier_symmetries/#AtomicSymmetries.symmetrize_matrix_q!","page":"Symmetries in Q space","title":"AtomicSymmetries.symmetrize_matrix_q!","text":"symmetrize_matrix_q!(target_q :: AbstractArray{Complex{T}, 3}, original_q :: AbstractArray{Complex{T}, 3}, symmetries :: Symmetries, irt_q :: Vector{Vector{Int}}; buffer = default_buffer() where T\nsymmetrize_matrix_q!(matrix_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T\nsymmetrize_matrix_q!(target_q :: AbstractArray{T, 3}, original_q :: AbstractArray{Complex{T}, 3}, q_symmetries :: SymmetriesQSpace; buffer = default_buffer())  where T\n\nImpose the symmetrization of a dynamical matrix in q space. The matrix must be in crystal coordinates.\n\nParameters\n\ntarget_q : The symmetrized matrix of size n_modes, n_modes, nq (modified in-place).\noriginal_q : The original matrix in q-space of size n_modes, n_modes, nq. It could be the same as target_q\nsymmetries : The symmetry group\nirt_q : A vector (one for each symmetry) of the correspondances of q points. For each symmetry can be obtained from get_irt_q!\nminus_q_index : A vector containing for each q the corresponding vec q = -vec q + vec G, where vec G is a generic reciprocal lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.jl-Documentation","page":"Home","title":"AtomicSymmetries.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package to enforce symmetry constraints on atomic positions in a crystal structure. It also works on dynamical matrices and force constants.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package also exploits a memory efficient representation of the symmetry independent components of a tensor. It can be used in pairs with Spglib.jl and the python version of spglib via PyCall for symmetry recognition.","category":"page"},{"location":"#The-symmetry-group","page":"Home","title":"The symmetry group","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The key object in this package is the Symmetries type, which represents a symmetry group. The Symmetries is a container for the symmetry operations under which the specific crystal is invariant.","category":"page"},{"location":"#AtomicSymmetries.Symmetries","page":"Home","title":"AtomicSymmetries.Symmetries","text":"mutable struct Symmetries{T}\n\nThe structure containing the symmetries of the system.\n\nOnce the symmetries have been initialized,  the symmetrizefc! and symmetrizecentroid! functions can be used to symmetrize the force constant matrix and the centroid.\n\nThe exchange_symmetry is a vector of length n_particles,  where each element identify the id of the particle. If two ids are equal, the particles are indistinguishable.\n\nirt[i][j] is the index of the atom that is equivalent to the j-th atom before the symmetry is applied. The expression is\n\nv_textirti = S v_i\n\nThe name irt stands for \"index of the representative of the transformation\". and it is in line with the notation used in the Quantum Espresso and the CellConstructor codes.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"To build the symmetry group, one can create the following constructor","category":"page"},{"location":"","page":"Home","title":"Home","text":"symmetry_group = get_identity_symmetry_group(Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will create a symmetry group with the identity operation only. The symmetry group can be extended by adding new symmetry operations with the function add_symmetry!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_symmetry!(symmetry_group, symmetry_operation; irt = nothing)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The symmetry_operation is a 3x3 matrix representing the rotation part of the symmetry operation. The optional argument irt is a vector representing how the symmetry operation exchanges the atoms. In particular the simmetry maps atom i to atom irti. If it is not provided,  the symmetry operation is assumed not to exchange the atoms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the fundamental symmetry operations have been added, the symmetry group can closed by completing the irreducible representation. This is done by the function complete_symmetry_group.","category":"page"},{"location":"","page":"Home","title":"Home","text":"complete_symmetry_group!(symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once completed, the symmetry group can be exploited to enforce symmetry constraints on  displacement vectors and 2-rank tensors as","category":"page"},{"location":"","page":"Home","title":"Home","text":"symmetry_group.symmetrize_centroid!(vector)\nsymmetry_group.symmetrize_fc!(matrix)","category":"page"},{"location":"#Build-your-own-symmetry-group-(API)","page":"Home","title":"Build your own symmetry group (API)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To build a custom symmetry group, you can exploit the following subroutines","category":"page"},{"location":"#AtomicSymmetries.complete_symmetry_group!","page":"Home","title":"AtomicSymmetries.complete_symmetry_group!","text":"complete_symmetry_group!(symmetries :: Symmetries{T})\n\nComplete the symmetry group by adding the inverse symmetry operations and the compositions of the symmetry operations, until the group is closed.\n\nSince symmetry are unitary transformations,  the inverse symmetry operation is the transpose of the symmetry operation.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.add_symmetry!","page":"Home","title":"AtomicSymmetries.add_symmetry!","text":"add_symmetry!(sym :: Symmetries{T}, symm :: Matrix{T}; update :: Bool = true, check_existing :: Bool = false) :: where {T}\n\nAdd a symmetry to the system.\n\nIf update is true, the symmetrizefc! and symmetrizecentroid! functions are updated. If check_existing is true, the symmetry is only added if it is not already in the list of symmetries.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_identity_symmetry_group","page":"Home","title":"AtomicSymmetries.get_identity_symmetry_group","text":"get_identity_symmetry_group(T :: Type) :: Symmetries{T}\n\nThis function returns the symmetry group containing only the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_cylindrical_symmetry_group","page":"Home","title":"AtomicSymmetries.get_cylindrical_symmetry_group","text":"get_cylindrical_symmetry_group(T :: Type, axis :: Int) :: Symmetries{T}\n\nThe cylindrical symmetry group is the group of all rotation around one axis, plus all inversions.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_spherical_symmetry_group","page":"Home","title":"AtomicSymmetries.get_spherical_symmetry_group","text":"get_spherical_symmetry_group(T :: Type, dims :: Int = 3) :: Symmetries{T}\n\nReturn the symmetry group of all rotation and inversion operations in the dimension of the system.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_full_inversion_symmetry_group","page":"Home","title":"AtomicSymmetries.get_full_inversion_symmetry_group","text":"get_full_inversion_symmetry_group(T :: Type, dims :: Int =2) :: Symmetries{T}\n\nReturn the group of inversion symmetries along the x, y, and z axis. This suppose that atoms are not exchanged by the symmetry.\n\n\n\n\n\n","category":"function"},{"location":"#Structure-symmetrization","page":"Home","title":"Structure symmetrization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sometimes it is useful to symmetrize the atomic positions of a crystal structure. To follow the correct Wyckoff positions.  This is achieved with the function symmetrize_positions!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"symmetrize_positions!(cartesian_coords, cell, symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function takes the atomic positions in cartesian coordinates, the cell matrix and the symmetry group. The cell must be column-wise, i.e., each column is a primitive vector of the cell.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here the API","category":"page"},{"location":"#AtomicSymmetries.symmetrize_positions!","page":"Home","title":"AtomicSymmetries.symmetrize_positions!","text":"symmetrize_positions!(positions :: AbstractMatrix{T}, cell :: AbstractMatrix, symmetry_group :: Symmetries; buffer=default_buffer()) where {T}\n\nsymmetrize an atomic coordinates in real space.  This subroutie symmetrizes a system with Cartesian coordinats (positions) using the specified symmetry group (that must include translations).\n\nIf you want to symmetrize a quantity that is invariant under translations (e.g. a force or a displacement), use symmetrize_vector! instead.\n\nThe function operates in place, meaning that the final result overwrites the input positions.\n\nThis function exploits Bumper.jl stack allocation to avoid memory allocation, you can manually specify the stack buffer as an optional keyword argument buffer.\n\n\n\n\n\n","category":"function"},{"location":"#The-symmetry-generators","page":"Home","title":"The symmetry generators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the symmetry group, we can obtain a vectorial subspace that is invariant under the symmetry operations. A basis of this subspace is given by the symmetry generators. For vectorial quantities, the generators can be obtained as","category":"page"},{"location":"","page":"Home","title":"Home","text":"generators = get_vector_generators(symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For 2-rank tensors, the generators can be obtained as","category":"page"},{"location":"","page":"Home","title":"Home","text":"generators = get_matrix_generators(symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generators are vectors of indexes that can be used to build the symmetry independent components of a tensor. This allows to store each generator as a 64-bit integer, which is more memory efficient than storing the full tensor. The full vector/2-rank tensor can be retriven with the function get_vector_generator/get_matrix_generator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Retrive the first element from the generators\ni = 1\nvector = zeros(3)\nget_vector_generator!(vector, generators[i], symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And analogously for 2-rank tensors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generators can be used to project any vector or 2-rank tensor in the symmetry invariant subspace.","category":"page"},{"location":"","page":"Home","title":"Home","text":"coefficients = zeros(length(generators))\nmy_vector = ...\nget_coefficients_from_vector!(coefficients, my_vector, generators, symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The previous function projects the vector my_vector in the symmetry invariant subspace and stores the coefficients in the vector coefficient. The coefficients can be used to reconstruct the original vector (symmetrized) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"final_vector = similar(my_vector)\nget_centroids_from_generators!(final_vector, generators, coefficients, symmetry_group)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same works for 2-rank tensors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get the coefficients of the matrix projected in the symmetric subspace\ncoefficients = zeros(length(generators))\nmy_matrix = ...\nget_coefficients_from_fc!(coefficients, my_matrix, generators, symmetry_group)\n\n# And reconstruct bach the matrix from the coefficients\nfinal_matrix = similar(my_matrix)\nget_fc_from_generators!(final_matrix, generators, coefficients, symmetry_group)","category":"page"},{"location":"#Generators-(API)","page":"Home","title":"Generators (API)","text":"","category":"section"},{"location":"#AtomicSymmetries.get_vector_generators","page":"Home","title":"AtomicSymmetries.get_vector_generators","text":"get_vector_generators(symmetry_group::Symmetries{U},\n                      unit_cell :: AbstractMatrix{T};\n                   func_apply_constraints! = nothing)\n                    :: Vector{Int} where {T, U}\n\nGet the generators of the symmetry group for the vectors.\n\nArguments\n\nsymmetry_group::Symmetries{U}: The symmetry group to be considered in the generator creation process.\nunit_cell :: AbstractMatrix{T}: The unit cell of the system.\nfunc_apply_constraints!::Function (optional): A function to apply constraints to the parameters. Defaults to nothing.\n\nReturns\n\nVector{Int}: A vector of indices representing the set of independent generators.\n\nDescription\n\nThis function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of vectors that are invariant under the symmetry group.\n\nNote that the generators are computed in cartesian coordinates(FC)\n\nThe independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.\n\nThe function ultimately returns a vector of indices representing the independent generators found during the process.\n\nExamples\n\nsymmetry_group = # Symmetries object\ngenerators = get_vector_generators(symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_matrix_generators","page":"Home","title":"AtomicSymmetries.get_matrix_generators","text":"get_matrix_generators(symmetry_group::Symmetries{U},\n                      unit_cell :: AbstractMatrix{T};\n                   func_apply_constraints! = nothing)\n                    :: Vector{Int} where {T, U}\n\nGet the generators of the symmetry group for the matrices.\n\nArguments\n\nsymmetry_group::Symmetries{U}: The symmetry group to be considered in the generator creation process.\nunit_cell :: AbstractMatrix{T}: The unit cell of the system.\nfunc_apply_constraints!::Function (optional): A function to apply constraints to the parameters. Defaults to nothing.\n\nReturns\n\nVector{Int}: A vector of indices representing the set of independent generators.\n\nDescription\n\nThis function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of matrices that are invariant under the symmetry group.\n\nNote that the generators are computed in cartesian coordinates(FC)\n\nThe independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.\n\nThe function ultimately returns a vector of indices representing the independent generators found during the process.\n\nExamples\n\nsymmetry_group = # Symmetries object\ngenerators = get_matrix_generators(symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_vector_generator!","page":"Home","title":"AtomicSymmetries.get_vector_generator!","text":"get_vector_generator!(generator::Vector{T}, generator_index::Int, n_modes::Int, n_layers::Int, symmetry_group::Symmetries{U};\n               use_sqrt_representation=true, optimize_struct=true, optimize_nltransf=true, \n               func_apply_constraints!=nothing, baseline_generator=nothing, normalize=true) where {T, U}\n\nModify generator in-place to represent a specific generator of a transformation, subject to given constraints and symmetries.\n\nThe generatorindex parameter ranges from 1 to Nmax, where N_max represents the maximum dimension of the parameters, and it should be noted that some indices within this range may yield identical generators due to the underlying symmetries or constraints in the system.\n\nArguments\n\ngenerator::Vector{T}: The generator vector to be modified.\ngenerator_index::Int: Index specifying which generator to construct.\nn_modes::Int: The number of modes in the system.\nn_layers::Int: The number of layers in the neural network model.\nsymmetry_group::Symmetries{U}: The symmetry group to be imposed on the generator.\nuse_sqrt_representation::Bool (optional): Flag to use the square root representation. Defaults to true.\noptimize_struct::Bool (optional): Flag to optimize the structure. Defaults to true.\noptimize_nltransf::Bool (optional): Flag to optimize nonlinear transformations. Defaults to true.\nfunc_apply_constraints!::Function (optional): A function to manually apply constraints to the parameters. Defaults to nothing.\nbaseline_generator::Vector{T} (optional): A baseline generator for comparison. Defaults to nothing.\nnormalize::Bool (optional): Flag to normalize the generator. Defaults to true.\n\nDescription\n\nThis function constructs a generator vector that represents a transformation in a specified manner. It initializes the generator vector with zeros and sets the generator_index element to 1. The function builds a scha (Structured Component Histogram Analysis) and an nltransf (Non-Linear Transform) based on the specified parameters. The scha and nltransf are then used to set the parameters of the generator.\n\nIf func_apply_constraints! is provided, it is used to apply constraints to the scha and nltransf. If baseline_generator is provided, the function adjusts the generator relative to this baseline. Symmetry constraints from symmetry_group are imposed on the nltransf and scha.\n\nFinally, the function updates the generator with the parameters obtained from scha and nltransf, optionally subtracting the baseline generator and normalizing the result.\n\nExamples\n\ngenerator = zeros(Float64, 10)\nget_vector_generator!(generator, 2, 5, 3, my_symmetry_group)\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_coefficients_from_vector!","page":"Home","title":"AtomicSymmetries.get_coefficients_from_vector!","text":"get_coefficients_from_vector!(coefficients :: Vector{T}, vector:: Vector{T}, generators :: Vector{Int},\n    n_modes::Int, n_layers :: Int;\n    use_sqrt_representation=true,\n    optimize_struct=true,\n    optimize_nltransf=true) where {T}\n\nGet the coefficients obtained as the scalar product between a vector and the generators:\n\nalpha_i = vec g_i cdot vec v\n\nwhere \\alpha_i is the i-th computed coefficient, \\vec g_i is the i-th generator, and \\vec v is the provided vector.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_centroids_from_generators!","page":"Home","title":"AtomicSymmetries.get_centroids_from_generators!","text":"get_centroids_from_generators!(centroids:: AbstractVector{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetries :: Symmetries, n_modes :: Int; kwargs...)\n\nReturn the parameters from the generators and the coefficients. The centroids vec v are obtained in-place as \n\nvec v = sum_i alpha_i vec g_i\n\nwhere \\alpha_i are the generator coefficients, while \\vec g_i is the i-th vector generator.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_coefficients_from_fc!","page":"Home","title":"AtomicSymmetries.get_coefficients_from_fc!","text":"get_coefficients_from_fc!(coefficients :: Vector{T}, matrix:: Matrix{T}, generators :: Vector{Int},\n    n_modes::Int, n_layers :: Int;\n    use_sqrt_representation=true,\n    optimize_struct=true,\n    optimize_nltransf=true) where {T}\n\nGet the coefficients obtained as the scalar product between a given matrix and the generators:\n\nalpha_i = textTr G_i M\n\nwhere \\alpha_i is the i-th computed coefficient, G_i is the i-th matrix generator, and M is the provided Matrix.\n\n\n\n\n\n","category":"function"},{"location":"#AtomicSymmetries.get_fc_from_generators!","page":"Home","title":"AtomicSymmetries.get_fc_from_generators!","text":"get_fc_from_generators!(fc:: AbstractMarix{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetryes :: Symmetries, cell :: AbstractMatrix; kwargs...)\n\nReturn the Matrix from the coefficient representation. The fc matrix M is obtained in-place as \n\nM = sum_i alpha_i G_i\n\nwhere \\alpha_i are the generator coefficients, while G_i is the i-th matrix generator.\n\n\n\n\n\n","category":"function"},{"location":"#Spglib-integration","page":"Home","title":"Spglib integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The symmetry group can be directly constructed exploiting Spglib to recognize the symmetry operations of a crystal structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_symmetry_group_from_spglib(positions::AbstractMatrix{<: Real}, cell::AbstractMatrix{<:Real}, types::Vector{<:Int};  symprec::Float64 = 1e-6, type::Type = Float64, spglib_py_module = nothing) :: Symmetries","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here the arguments are the atomic positions (in crystal coordinates), the cell matrix and the atomic types. Optionally, the symprec parameter can be used to set the tolerance for the symmetry recognition (passed to Spglib).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the Spglib.jl implementation is much less mature than the python version,  if needed, it is possible to pass the module of the python version of spglib to the function to replace the Spglib.jl implementation with the Python API from the official spglib package. This requires PyCall.jl to be installed.","category":"page"},{"location":"#Spglib-API","page":"Home","title":"Spglib API","text":"","category":"section"},{"location":"#AtomicSymmetries.get_symmetry_group_from_spglib","page":"Home","title":"AtomicSymmetries.get_symmetry_group_from_spglib","text":"get_symmetry_group_from_spglib(positions :: AbstractMatrix, cell :: AbstractMatrix, types :: Array{Int}; \n    symprec :: Float64 = 1e-6,\n    type :: Type = Float64, spglib_py_module = nothing) :: Symmetries\n\nBuild a symmetry group from the spglib library. Optionally, this function can be called with a spglib python module. In this way, the python module will be used to get the symmetry operations (since the julia spglib module is buggy).\n\nArguments\n\npositions::AbstractMatrix: The atomic positions in the cell (crystallographic coordinates), with shape (3, N).\ncell::AbstractMatrix: The cell matrix with shape (3, 3).\ntypes::Array{Int}: The atomic types.\n\nOptional arguments:\n\nsymprec::Float64: The symmetry precision.\ntype::Type: The numerical precision type for the symmetry operations.\nspglib_py_module: The spglib python module. If not provided, the default julia spglib module is used.\n\nAlternatively, you can pass an ASE Atoms object.\n\n\n\n\n\n","category":"function"},{"location":"#How-to-get-crystal-coordinates","page":"Home","title":"How to get crystal coordinates","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code also allows for a quick conversion between cartesian and crystal coordinates. Assuming cartesian_positions is a 3xNat matrix of atomic positions in cartesian coordinates and cell is the 3x3 cell matrix (each column is a primitive vector), the crystal coordinates can be obtained as","category":"page"},{"location":"","page":"Home","title":"Home","text":"crystal_positions = similar(cartesian_positions)\nget_crystal_coords!(crystal_positions, cartesian_positions, cell)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optionally, a Bumper.jl buffer can be passed to the function to avoid memory allocations, otherwise, the default_buffer() is retrived.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The cartesian coordinates can be obtained as","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_cartesian_coords!(cartesian_positions, crystal_positions, cell)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function does not require any memory allocation.","category":"page"},{"location":"#Filter-symmetries","page":"Home","title":"Filter symmetries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is possible to filter symmetries incompatible with a given external perturbation. At this stage, only linear perturbations are supported. For example, to filter the symmetries that are not compatible with a perturbation along the x direction, one can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"filter_invariant_symmetries!(symmetry_group, [1.0, 0.0, 0.0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"All symmetry operations not leaving the perturbation vector invariant are removed from the symmetry group. Since version 0.2, it is possible to parse a vector of size ndimension * natoms,  with a different displacement vector acting on each atom.","category":"page"},{"location":"#AtomicSymmetries.filter_invariant_symmetries!","page":"Home","title":"AtomicSymmetries.filter_invariant_symmetries!","text":"filter_invariant_symmetries!(symmetry_group :: Symmetries, vector :: AbstractVector, cell :: AbstractMatrix;\n                             buffer=default_buffer())\n\nThis subroutine filters the symmetries in symmetry_group that does  not leave the vector vector invariant under their transformation.\n\nNote that vector is assumed in Cartesian coordinates (not crystalline) since version 0.6.0\n\nFor example, inversion symmetry is not compatible with a vector that is not the null vector, so it will be removed from the symmetry group. While a reflection symmetry is compatible with any vector lying on the reflection plane,  so it will be kept in the symmetry group.\n\nThis is userful if the symmetries are evaluated from a set of atomic positions, But we then need symmetries that also are invariant under an external perturbation along a certain direction.\n\n\n\n\n\n","category":"function"},{"location":"#Symmetry-sparsification","page":"Home","title":"Symmetry sparsification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A new feature available since version 0.7 is the possibility to get the symmetry matrices as CSC sparse matrices. To sparsify a symmetry group, you just need to use the sparse method from the SparseArrays library (novel dependency of 0.7)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using SparseArrays\nsparse_symmetry_group = sparse(symmetry_group)\n\n# Apply the symmetry 5th operation on a vector v (previosly defined)\nv_new = apply_sparse_symmetry(sparse_symmetry_group.symmetries[5], v)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notably, this is differentiable via Zygote and Enzyme, so it allows to implement symmetrization in a differentiable way. v could also be a series of vector as a Matrix where each vector is stored as a column of v.","category":"page"},{"location":"#AtomicSymmetries.apply_sparse_symmetry","page":"Home","title":"AtomicSymmetries.apply_sparse_symmetry","text":"function apply_sparse_symmetry(sparse_s :: SparseMatrixCSC{T}, v :: AbstractArray{U}) where {T, U}\n\nThis function applies the sparse symmetry matrix to a displacement vector.\n\nThe inplace version should be nonallocating.\n\n\n\n\n\n","category":"function"}]
}

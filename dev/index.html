<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · AtomicSymmetries.jl Documentation</title><meta name="title" content="Home · AtomicSymmetries.jl Documentation"/><meta property="og:title" content="Home · AtomicSymmetries.jl Documentation"/><meta property="twitter:title" content="Home · AtomicSymmetries.jl Documentation"/><meta name="description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="og:description" content="Documentation for AtomicSymmetries.jl Documentation."/><meta property="twitter:description" content="Documentation for AtomicSymmetries.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AtomicSymmetries.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#The-symmetry-group"><span>The symmetry group</span></a></li><li><a class="tocitem" href="#The-symmetry-generators"><span>The symmetry generators</span></a></li><li><a class="tocitem" href="#Spglib-integration"><span>Spglib integration</span></a></li><li><a class="tocitem" href="#Filter-symmetries"><span>Filter symmetries</span></a></li><li><a class="tocitem" href="#Symmetry-sparsification"><span>Symmetry sparsification</span></a></li></ul></li><li><a class="tocitem" href="fourier_symmetries/">Symmetries in Q space</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AtomicSymmetries.jl-Documentation"><a class="docs-heading-anchor" href="#AtomicSymmetries.jl-Documentation">AtomicSymmetries.jl Documentation</a><a id="AtomicSymmetries.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#AtomicSymmetries.jl-Documentation" title="Permalink"></a></h1><p>A package to enforce symmetry constraints on atomic positions in a crystal structure. It also works on dynamical matrices and force constants.</p><p>The package also exploits a memory efficient representation of the symmetry independent components of a tensor. It can be used in pairs with <code>Spglib.jl</code> and the python version of spglib via PyCall for symmetry recognition.</p><h2 id="The-symmetry-group"><a class="docs-heading-anchor" href="#The-symmetry-group">The symmetry group</a><a id="The-symmetry-group-1"></a><a class="docs-heading-anchor-permalink" href="#The-symmetry-group" title="Permalink"></a></h2><p>The key object in this package is the <code>Symmetries</code> type, which represents a symmetry group. The <span>$Symmetries$</span> is a container for the symmetry operations under which the specific crystal is invariant.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.Symmetries" href="#AtomicSymmetries.Symmetries"><code>AtomicSymmetries.Symmetries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Symmetries{T}</code></pre><p>The structure containing the symmetries of the system.</p><p>Once the symmetries have been initialized,  the symmetrize<em>fc! and symmetrize</em>centroid! functions can be used to symmetrize the force constant matrix and the centroid.</p><p>The <code>exchange_symmetry</code> is a vector of length <code>n_particles</code>,  where each element identify the id of the particle. If two ids are equal, the particles are indistinguishable.</p><p>irt[i][j] is the index of the atom that is equivalent to the j-th atom before the symmetry is applied. The expression is</p><p><span>$v_{\text{irt[i]}} = S v_i$</span></p><p>The name irt stands for &quot;index of the representative of the transformation&quot;. and it is in line with the notation used in the Quantum Espresso and the CellConstructor codes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L15-L37">source</a></section></article><p>To build the symmetry group, one can create the following constructor</p><pre><code class="language-julia hljs">symmetry_group = get_identity_symmetry_group(Float64)</code></pre><p>This will create a symmetry group with the identity operation only. The symmetry group can be extended by adding new symmetry operations with the function <code>add_symmetry!</code>.</p><pre><code class="language-julia hljs">add_symmetry!(symmetry_group, symmetry_operation; irt = nothing)</code></pre><p>The <span>$symmetry_operation$</span> is a 3x3 matrix representing the rotation part of the symmetry operation. The optional argument <span>$irt$</span> is a vector representing how the symmetry operation exchanges the atoms. In particular the simmetry maps atom <span>$i$</span> to atom <span>$irt[i]$</span>. If it is not provided,  the symmetry operation is assumed not to exchange the atoms.</p><p>Once the fundamental symmetry operations have been added, the symmetry group can closed by completing the irreducible representation. This is done by the function <span>$complete_symmetry_group!$</span>.</p><pre><code class="language-julia hljs">complete_symmetry_group!(symmetry_group)</code></pre><p>Once completed, the symmetry group can be exploited to enforce symmetry constraints on  displacement vectors and 2-rank tensors as</p><pre><code class="language-julia hljs">symmetry_group.symmetrize_centroid!(vector)
symmetry_group.symmetrize_fc!(matrix)</code></pre><h3 id="Build-your-own-symmetry-group-(API)"><a class="docs-heading-anchor" href="#Build-your-own-symmetry-group-(API)">Build your own symmetry group (API)</a><a id="Build-your-own-symmetry-group-(API)-1"></a><a class="docs-heading-anchor-permalink" href="#Build-your-own-symmetry-group-(API)" title="Permalink"></a></h3><p>To build a custom symmetry group, you can exploit the following subroutines</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.complete_symmetry_group!" href="#AtomicSymmetries.complete_symmetry_group!"><code>AtomicSymmetries.complete_symmetry_group!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete_symmetry_group!(symmetries :: Symmetries{T})</code></pre><p>Complete the symmetry group by adding the inverse symmetry operations and the compositions of the symmetry operations, until the group is closed.</p><p>Since symmetry are unitary transformations,  the inverse symmetry operation is the transpose of the symmetry operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L536-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.add_symmetry!" href="#AtomicSymmetries.add_symmetry!"><code>AtomicSymmetries.add_symmetry!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_symmetry!(sym :: Symmetries{T}, symm :: Matrix{T}; update :: Bool = true, check_existing :: Bool = false) :: where {T}</code></pre><p>Add a symmetry to the system.</p><p>If update is true, the symmetrize<em>fc! and symmetrize</em>centroid! functions are updated. If check_existing is true, the symmetry is only added if it is not already in the list of symmetries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_identity_symmetry_group" href="#AtomicSymmetries.get_identity_symmetry_group"><code>AtomicSymmetries.get_identity_symmetry_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_identity_symmetry_group(T :: Type) :: Symmetries{T}</code></pre><p>This function returns the symmetry group containing only the identity matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L683-L688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_cylindrical_symmetry_group" href="#AtomicSymmetries.get_cylindrical_symmetry_group"><code>AtomicSymmetries.get_cylindrical_symmetry_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cylindrical_symmetry_group(T :: Type, axis :: Int) :: Symmetries{T}</code></pre><p>The cylindrical symmetry group is the group of all rotation around one axis, plus all inversions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L660-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_spherical_symmetry_group" href="#AtomicSymmetries.get_spherical_symmetry_group"><code>AtomicSymmetries.get_spherical_symmetry_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_spherical_symmetry_group(T :: Type, dims :: Int = 3) :: Symmetries{T}</code></pre><p>Return the symmetry group of all rotation and inversion operations in the dimension of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L618-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_full_inversion_symmetry_group" href="#AtomicSymmetries.get_full_inversion_symmetry_group"><code>AtomicSymmetries.get_full_inversion_symmetry_group</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_full_inversion_symmetry_group(T :: Type, dims :: Int =2) :: Symmetries{T}</code></pre><p>Return the group of inversion symmetries along the x, y, and z axis. This suppose that atoms are not exchanged by the symmetry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L590-L596">source</a></section></article><h3 id="Structure-symmetrization"><a class="docs-heading-anchor" href="#Structure-symmetrization">Structure symmetrization</a><a id="Structure-symmetrization-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-symmetrization" title="Permalink"></a></h3><p>Sometimes it is useful to symmetrize the atomic positions of a crystal structure. To follow the correct Wyckoff positions.  This is achieved with the function <code>symmetrize_positions!</code>.</p><pre><code class="language-julia hljs">symmetrize_positions!(cartesian_coords, cell, symmetry_group)</code></pre><p>This function takes the atomic positions in cartesian coordinates, the cell matrix and the symmetry group. The cell must be column-wise, i.e., each column is a primitive vector of the cell.</p><p>Here the API</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.symmetrize_positions!" href="#AtomicSymmetries.symmetrize_positions!"><code>AtomicSymmetries.symmetrize_positions!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_positions!(positions :: AbstractMatrix{T}, cell :: AbstractMatrix, symmetry_group :: Symmetries; buffer=default_buffer()) where {T}</code></pre><p>symmetrize an atomic coordinates in real space.  This subroutie symmetrizes a system with Cartesian coordinats (positions) using the specified symmetry group (that must include translations).</p><p>If you want to symmetrize a quantity that is invariant under translations (e.g. a force or a displacement), use <code>symmetrize_vector!</code> instead.</p><p>The function operates in place, meaning that the final result overwrites the input positions.</p><p>This function exploits Bumper.jl stack allocation to avoid memory allocation, you can manually specify the stack buffer as an optional keyword argument <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/symmetries_core.jl#L208-L223">source</a></section></article><h2 id="The-symmetry-generators"><a class="docs-heading-anchor" href="#The-symmetry-generators">The symmetry generators</a><a id="The-symmetry-generators-1"></a><a class="docs-heading-anchor-permalink" href="#The-symmetry-generators" title="Permalink"></a></h2><p>From the symmetry group, we can obtain a vectorial subspace that is invariant under the symmetry operations. A basis of this subspace is given by the symmetry generators. For vectorial quantities, the generators can be obtained as</p><pre><code class="language-julia hljs">generators = get_vector_generators(symmetry_group)</code></pre><p>For 2-rank tensors, the generators can be obtained as</p><pre><code class="language-julia hljs">generators = get_matrix_generators(symmetry_group)</code></pre><p>The generators are vectors of indexes that can be used to build the symmetry independent components of a tensor. This allows to store each generator as a 64-bit integer, which is more memory efficient than storing the full tensor. The full vector/2-rank tensor can be retriven with the function <span>$get_vector_generator!$</span>/<span>$get_matrix_generator!$</span>.</p><pre><code class="language-julia hljs"># Retrive the first element from the generators
i = 1
vector = zeros(3)
get_vector_generator!(vector, generators[i], symmetry_group)</code></pre><p>And analogously for 2-rank tensors.</p><p>The generators can be used to project any vector or 2-rank tensor in the symmetry invariant subspace.</p><pre><code class="language-julia hljs">coefficients = zeros(length(generators))
my_vector = ...
get_coefficients_from_vector!(coefficients, my_vector, generators, symmetry_group)</code></pre><p>The previous function projects the vector <code>my_vector</code> in the symmetry invariant subspace and stores the coefficients in the vector <code>coefficient</code>. The coefficients can be used to reconstruct the original vector (symmetrized) as</p><pre><code class="language-julia hljs">final_vector = similar(my_vector)
get_centroids_from_generators!(final_vector, generators, coefficients, symmetry_group)</code></pre><p>The same works for 2-rank tensors.</p><pre><code class="language-julia hljs"># Get the coefficients of the matrix projected in the symmetric subspace
coefficients = zeros(length(generators))
my_matrix = ...
get_coefficients_from_fc!(coefficients, my_matrix, generators, symmetry_group)

# And reconstruct bach the matrix from the coefficients
final_matrix = similar(my_matrix)
get_fc_from_generators!(final_matrix, generators, coefficients, symmetry_group)</code></pre><h3 id="Generators-(API)"><a class="docs-heading-anchor" href="#Generators-(API)">Generators (API)</a><a id="Generators-(API)-1"></a><a class="docs-heading-anchor-permalink" href="#Generators-(API)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_vector_generators" href="#AtomicSymmetries.get_vector_generators"><code>AtomicSymmetries.get_vector_generators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_vector_generators(symmetry_group::Symmetries{U},
                      unit_cell :: AbstractMatrix{T};
                   func_apply_constraints! = nothing)
                    :: Vector{Int} where {T, U}</code></pre><p>Get the generators of the symmetry group for the vectors.</p><p><strong>Arguments</strong></p><ul><li><code>symmetry_group::Symmetries{U}</code>: The symmetry group to be considered in the generator creation process.</li><li><code>unit_cell :: AbstractMatrix{T}</code>: The unit cell of the system.</li><li><code>func_apply_constraints!::Function</code> (optional): A function to apply constraints to the parameters. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A vector of indices representing the set of independent generators.</li></ul><p><strong>Description</strong></p><p>This function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of vectors that are invariant under the symmetry group.</p><p>Note that the generators are computed in cartesian coordinates(FC)</p><p>The independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.</p><p>The function ultimately returns a vector of indices representing the independent generators found during the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">symmetry_group = # Symmetries object
generators = get_vector_generators(symmetry_group)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_matrix_generators" href="#AtomicSymmetries.get_matrix_generators"><code>AtomicSymmetries.get_matrix_generators</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_matrix_generators(symmetry_group::Symmetries{U},
                      unit_cell :: AbstractMatrix{T};
                   func_apply_constraints! = nothing)
                    :: Vector{Int} where {T, U}</code></pre><p>Get the generators of the symmetry group for the matrices.</p><p><strong>Arguments</strong></p><ul><li><code>symmetry_group::Symmetries{U}</code>: The symmetry group to be considered in the generator creation process.</li><li><code>unit_cell :: AbstractMatrix{T}</code>: The unit cell of the system.</li><li><code>func_apply_constraints!::Function</code> (optional): A function to apply constraints to the parameters. Defaults to <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A vector of indices representing the set of independent generators.</li></ul><p><strong>Description</strong></p><p>This function generates a set of independent generators for a given symmetry group. These generators proved a basis for the space of matrices that are invariant under the symmetry group.</p><p>Note that the generators are computed in cartesian coordinates(FC)</p><p>The independence of a generator is determined by its norm and its linear independence from previously accepted generators. If a generator is found to be linearly dependent but not identical to a previous one, the function throws an error indicating that this scenario is not yet implemented.</p><p>The function ultimately returns a vector of indices representing the independent generators found during the process.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">symmetry_group = # Symmetries object
generators = get_matrix_generators(symmetry_group)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L105-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_vector_generator!" href="#AtomicSymmetries.get_vector_generator!"><code>AtomicSymmetries.get_vector_generator!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_vector_generator!(generator::Vector{T}, generator_index::Int, n_modes::Int, n_layers::Int, symmetry_group::Symmetries{U};
               use_sqrt_representation=true, optimize_struct=true, optimize_nltransf=true, 
               func_apply_constraints!=nothing, baseline_generator=nothing, normalize=true) where {T, U}</code></pre><p>Modify <code>generator</code> in-place to represent a specific generator of a transformation, subject to given constraints and symmetries.</p><p>The generator<em>index parameter ranges from 1 to N</em>max, where N_max represents the maximum dimension of the parameters, and it should be noted that some indices within this range may yield identical generators due to the underlying symmetries or constraints in the system.</p><p><strong>Arguments</strong></p><ul><li><code>generator::Vector{T}</code>: The generator vector to be modified.</li><li><code>generator_index::Int</code>: Index specifying which generator to construct.</li><li><code>n_modes::Int</code>: The number of modes in the system.</li><li><code>n_layers::Int</code>: The number of layers in the neural network model.</li><li><code>symmetry_group::Symmetries{U}</code>: The symmetry group to be imposed on the generator.</li><li><code>use_sqrt_representation::Bool</code> (optional): Flag to use the square root representation. Defaults to <code>true</code>.</li><li><code>optimize_struct::Bool</code> (optional): Flag to optimize the structure. Defaults to <code>true</code>.</li><li><code>optimize_nltransf::Bool</code> (optional): Flag to optimize nonlinear transformations. Defaults to <code>true</code>.</li><li><code>func_apply_constraints!::Function</code> (optional): A function to manually apply constraints to the parameters. Defaults to <code>nothing</code>.</li><li><code>baseline_generator::Vector{T}</code> (optional): A baseline generator for comparison. Defaults to <code>nothing</code>.</li><li><code>normalize::Bool</code> (optional): Flag to normalize the generator. Defaults to <code>true</code>.</li></ul><p><strong>Description</strong></p><p>This function constructs a generator vector that represents a transformation in a specified manner. It initializes the <code>generator</code> vector with zeros and sets the <code>generator_index</code> element to 1. The function builds a <code>scha</code> (Structured Component Histogram Analysis) and an <code>nltransf</code> (Non-Linear Transform) based on the specified parameters. The <code>scha</code> and <code>nltransf</code> are then used to set the parameters of the generator.</p><p>If <code>func_apply_constraints!</code> is provided, it is used to apply constraints to the <code>scha</code> and <code>nltransf</code>. If <code>baseline_generator</code> is provided, the function adjusts the generator relative to this baseline. Symmetry constraints from <code>symmetry_group</code> are imposed on the <code>nltransf</code> and <code>scha</code>.</p><p>Finally, the function updates the <code>generator</code> with the parameters obtained from <code>scha</code> and <code>nltransf</code>, optionally subtracting the baseline generator and normalizing the result.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">generator = zeros(Float64, 10)
get_vector_generator!(generator, 2, 5, 3, my_symmetry_group)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L224-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_coefficients_from_vector!" href="#AtomicSymmetries.get_coefficients_from_vector!"><code>AtomicSymmetries.get_coefficients_from_vector!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_coefficients_from_vector!(coefficients :: Vector{T}, vector:: Vector{T}, generators :: Vector{Int},
    n_modes::Int, n_layers :: Int;
    use_sqrt_representation=true,
    optimize_struct=true,
    optimize_nltransf=true) where {T}</code></pre><p>Get the coefficients obtained as the scalar product between a vector and the generators:</p><p><span>$\alpha_i = \vec g_i \cdot \vec v$</span></p><p>where <code>\alpha_i</code> is the i-th computed coefficient, <code>\vec g_i</code> is the i-th generator, and <code>\vec v</code> is the provided vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L455-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_centroids_from_generators!" href="#AtomicSymmetries.get_centroids_from_generators!"><code>AtomicSymmetries.get_centroids_from_generators!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_centroids_from_generators!(centroids:: AbstractVector{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetries :: Symmetries, n_modes :: Int; kwargs...)</code></pre><p>Return the parameters from the generators and the coefficients. The <code>centroids</code> <span>$\vec v$</span> are obtained in-place as </p><p><span>$\vec v = \sum_i \alpha_i \vec g_i$</span></p><p>where <code>\alpha_i</code> are the generator coefficients, while <code>\vec g_i</code> is the i-th vector generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L379-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_coefficients_from_fc!" href="#AtomicSymmetries.get_coefficients_from_fc!"><code>AtomicSymmetries.get_coefficients_from_fc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_coefficients_from_fc!(coefficients :: Vector{T}, matrix:: Matrix{T}, generators :: Vector{Int},
    n_modes::Int, n_layers :: Int;
    use_sqrt_representation=true,
    optimize_struct=true,
    optimize_nltransf=true) where {T}</code></pre><p>Get the coefficients obtained as the scalar product between a given matrix and the generators:</p><p><span>$\alpha_i = \text{Tr} G_i M$</span></p><p>where <code>\alpha_i</code> is the i-th computed coefficient, <code>G_i</code> is the i-th matrix generator, and <code>M</code> is the provided Matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L485-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_fc_from_generators!" href="#AtomicSymmetries.get_fc_from_generators!"><code>AtomicSymmetries.get_fc_from_generators!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_fc_from_generators!(fc:: AbstractMarix{T}, generators::Vector{Int}, coefficients :: Vector{T}, symmetryes :: Symmetries, cell :: AbstractMatrix; kwargs...)</code></pre><p>Return the Matrix from the coefficient representation. The <code>fc</code> matrix <span>$M$</span> is obtained in-place as </p><p><span>$M = \sum_i \alpha_i G_i$</span></p><p>where <code>\alpha_i</code> are the generator coefficients, while <code>G_i</code> is the i-th matrix generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/generators.jl#L412-L423">source</a></section></article><h2 id="Spglib-integration"><a class="docs-heading-anchor" href="#Spglib-integration">Spglib integration</a><a id="Spglib-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Spglib-integration" title="Permalink"></a></h2><p>The symmetry group can be directly constructed exploiting Spglib to recognize the symmetry operations of a crystal structure.</p><pre><code class="language-julia hljs">get_symmetry_group_from_spglib(positions::AbstractMatrix{&lt;: Real}, cell::AbstractMatrix{&lt;:Real}, types::Vector{&lt;:Int};  symprec::Float64 = 1e-6, type::Type = Float64, spglib_py_module = nothing) :: Symmetries</code></pre><p>Here the arguments are the atomic positions (in crystal coordinates), the cell matrix and the atomic types. Optionally, the symprec parameter can be used to set the tolerance for the symmetry recognition (passed to Spglib).</p><p>Since the <code>Spglib.jl</code> implementation is much less mature than the python version,  if needed, it is possible to pass the module of the python version of spglib to the function to replace the Spglib.jl implementation with the Python API from the official spglib package. This requires <code>PyCall.jl</code> to be installed.</p><h3 id="Spglib-API"><a class="docs-heading-anchor" href="#Spglib-API">Spglib API</a><a id="Spglib-API-1"></a><a class="docs-heading-anchor-permalink" href="#Spglib-API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.get_symmetry_group_from_spglib" href="#AtomicSymmetries.get_symmetry_group_from_spglib"><code>AtomicSymmetries.get_symmetry_group_from_spglib</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_symmetry_group_from_spglib(positions :: AbstractMatrix, cell :: AbstractMatrix, types :: Array{Int}; 
    symprec :: Float64 = 1e-6,
    type :: Type = Float64, spglib_py_module = nothing) :: Symmetries</code></pre><p>Build a symmetry group from the spglib library. Optionally, this function can be called with a spglib python module. In this way, the python module will be used to get the symmetry operations (since the julia spglib module is buggy).</p><p><strong>Arguments</strong></p><ul><li><code>positions::AbstractMatrix</code>: The atomic positions in the cell (crystallographic coordinates), with shape <code>(3, N)</code>.</li><li><code>cell::AbstractMatrix</code>: The cell matrix with shape <code>(3, 3)</code>.</li><li><code>types::Array{Int}</code>: The atomic types.</li></ul><p>Optional arguments:</p><ul><li><code>symprec::Float64</code>: The symmetry precision.</li><li><code>type::Type</code>: The numerical precision type for the symmetry operations.</li><li><code>spglib_py_module</code>: The spglib python module. If not provided, the default julia spglib module is used.</li></ul><p>Alternatively, you can pass an ASE Atoms object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/spglib_init.jl#L4-L25">source</a></section></article><h3 id="How-to-get-crystal-coordinates"><a class="docs-heading-anchor" href="#How-to-get-crystal-coordinates">How to get crystal coordinates</a><a id="How-to-get-crystal-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-get-crystal-coordinates" title="Permalink"></a></h3><p>The code also allows for a quick conversion between cartesian and crystal coordinates. Assuming <code>cartesian_positions</code> is a 3xNat matrix of atomic positions in cartesian coordinates and <code>cell</code> is the 3x3 cell matrix (each column is a primitive vector), the crystal coordinates can be obtained as</p><pre><code class="language-julia hljs">crystal_positions = similar(cartesian_positions)
get_crystal_coords!(crystal_positions, cartesian_positions, cell)</code></pre><p>Optionally, a <code>Bumper.jl</code> buffer can be passed to the function to avoid memory allocations, otherwise, the <code>default_buffer()</code> is retrived.</p><p>The cartesian coordinates can be obtained as</p><pre><code class="language-julia hljs">get_cartesian_coords!(cartesian_positions, crystal_positions, cell)</code></pre><p>This function does not require any memory allocation.</p><h2 id="Filter-symmetries"><a class="docs-heading-anchor" href="#Filter-symmetries">Filter symmetries</a><a id="Filter-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-symmetries" title="Permalink"></a></h2><p>It is possible to filter symmetries incompatible with a given external perturbation. At this stage, only linear perturbations are supported. For example, to filter the symmetries that are not compatible with a perturbation along the x direction, one can use</p><pre><code class="language-julia hljs">filter_invariant_symmetries!(symmetry_group, [1.0, 0.0, 0.0])</code></pre><p>All symmetry operations not leaving the perturbation vector invariant are removed from the symmetry group. Since version 0.2, it is possible to parse a vector of size n<em>dimension * n</em>atoms,  with a different displacement vector acting on each atom.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.filter_invariant_symmetries!" href="#AtomicSymmetries.filter_invariant_symmetries!"><code>AtomicSymmetries.filter_invariant_symmetries!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_invariant_symmetries!(symmetry_group :: Symmetries, vector :: AbstractVector, cell :: AbstractMatrix;
                             buffer=default_buffer())</code></pre><p>This subroutine filters the symmetries in <code>symmetry_group</code> that does  not leave the vector <code>vector</code> invariant under their transformation.</p><p>Note that <code>vector</code> is assumed in Cartesian coordinates (not crystalline) since version 0.6.0</p><p>For example, inversion symmetry is not compatible with a vector that is not the null vector, so it will be removed from the symmetry group. While a reflection symmetry is compatible with any vector lying on the reflection plane,  so it will be kept in the symmetry group.</p><p>This is userful if the symmetries are evaluated from a set of atomic positions, But we then need symmetries that also are invariant under an external perturbation along a certain direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/filter_symmetries.jl#L1-L17">source</a></section></article><h2 id="Symmetry-sparsification"><a class="docs-heading-anchor" href="#Symmetry-sparsification">Symmetry sparsification</a><a id="Symmetry-sparsification-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry-sparsification" title="Permalink"></a></h2><p>A new feature available since version 0.7 is the possibility to get the symmetry matrices as CSC sparse matrices. To sparsify a symmetry group, you just need to use the <code>sparse</code> method from the SparseArrays library (novel dependency of 0.7)</p><pre><code class="language-julia hljs">Using SparseArrays
sparse_symmetry_group = sparse(symmetry_group)

# Apply the symmetry 5th operation on a vector v (previosly defined)
v_new = apply_sparse_symmetry(sparse_symmetry_group.symmetries[5], v)</code></pre><p>Notably, this is differentiable via Zygote and Enzyme, so it allows to implement symmetrization in a differentiable way. v could also be a series of vector as a Matrix where each vector is stored as a column of v.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomicSymmetries.apply_sparse_symmetry" href="#AtomicSymmetries.apply_sparse_symmetry"><code>AtomicSymmetries.apply_sparse_symmetry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function apply_sparse_symmetry(sparse_s :: SparseMatrixCSC{T}, v :: AbstractArray{U}) where {T, U}</code></pre><p>This function applies the sparse symmetry matrix to a displacement vector.</p><p>The inplace version should be nonallocating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mesonepigreco/AtomicSymmetries.jl/blob/04962ba1c344b8f6e9fe8bb8de2486d04390f933/src/sparsify.jl#L82-L88">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="fourier_symmetries/">Symmetries in Q space »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 08:39">Thursday 4 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
